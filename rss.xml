<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>敬维</title>
    <description>一个喜欢涂涂画画的人，曾经的Rubist，一个CI/CD的践行者，一个探寻最佳实践的人。</description>
    <link>https://jingwei.link//</link>
    <atom:link href="https://jingwei.link/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 17 May 2020 18:14:13 +0800</pubDate>
    <lastBuildDate>Sun, 17 May 2020 18:14:13 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>《从0到1学习后端开发》之git安装、概念图解及简单使用</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#写在前面&quot; id=&quot;markdown-toc-写在前面&quot;&gt;写在前面&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#下载并安装-git&quot; id=&quot;markdown-toc-下载并安装-git&quot;&gt;下载并安装 git&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#git-概论&quot; id=&quot;markdown-toc-git-概论&quot;&gt;Git 概论&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#git中的概念&quot; id=&quot;markdown-toc-git中的概念&quot;&gt;git中的概念&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#在-vscode-中使用-git&quot; id=&quot;markdown-toc-在-vscode-中使用-git&quot;&gt;在 vscode 中使用 git&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#通过图形界面实战&quot; id=&quot;markdown-toc-通过图形界面实战&quot;&gt;通过图形界面实战&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#通过命令行实战&quot; id=&quot;markdown-toc-通过命令行实战&quot;&gt;通过命令行实战&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#小结&quot; id=&quot;markdown-toc-小结&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;本文是《从0到1学习后端开发》的首篇教案文档。《从0到1学习后端开发》是面向在校大学生、非 IT 工作人员的后端开发入门实践教程，可至 &lt;a href=&quot;https://space.bilibili.com/425571569&quot;&gt;https://space.bilibili.com/425571569&lt;/a&gt; 查看对应的视频资料。&lt;/p&gt;

&lt;h2 id=&quot;下载并安装-git&quot;&gt;下载并安装 git&lt;/h2&gt;

&lt;p&gt;在 ubuntu 中下载安装 git 还是比较简单的，&lt;/p&gt;

&lt;p&gt;我们可以打开 terminal 终端，首先敲击 &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt; 命令，如果我们系统还没有安装 git， console 会提示我们“尚未安装 git”，并且给出 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo apt install git&lt;/code&gt; 的命令，这个时候我们只需要复制这条命令，然后粘贴到命令行执行就可以了。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;git 

&lt;span class=&quot;c&quot;&gt;# 下面就是长篇的安装输出提示，可能会要求我们输入 Y，输入即可&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# ....&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;安装完成之后， git 就可以作为我们的一个工具来使用了。&lt;/p&gt;

&lt;h2 id=&quot;git-概论&quot;&gt;Git 概论&lt;/h2&gt;

&lt;p&gt;对于一个完整的项目来说，可能包含了很多的模块，整体向外提供一套完整的服务。我们在项目的开发的过程中，可能会首先编写一个模块的代码，然后再开发另一个模块的代码。对于一个中大型的项目，甚至会不同的人负责不同的模块进行开发。&lt;/p&gt;

&lt;p&gt;在项目创建初期，各个模块之间的关联关系比较清晰，每个开发者的职责划分也比较清晰。不过为了更好地审视整个系统的功能，依然需要一个明确的方式来 review（审核） 代码。比如 模块（或类）A 的同事依赖调用 模块（或类）B 的接口，那么架构层面的负责人可能会同时查看两个模块的代码，从而保证各自的逻辑是恰当的。同时也要能够跟踪每条语句的作者，一方面可以记录贡献，另一方面在出现疑问或问题的时候也可以第一时间找到编码者进行答疑或修正。&lt;/p&gt;

&lt;p&gt;到功能迭代阶段，除去新的模块或类，一般还会修改已有的模块或类，这个时候就特别需要收集“老代码”的各种信息，比如作者、修改记录、注释、文档等；同时为了以后方便进一步迭代，需要留下当前的记录、注释、文档等。按照时间线把一次次变更详情记录下来，这就是 git 工具的核心功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/003_git_concepts_01.png&quot; alt=&quot;git概念&quot; title=&quot;Git概念图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中，左边表示我们项目视角的结构图，每个方框表示一个模块，各个模块相互联系耦合到一起共同形成一个系统，整体向外提供服务；右边表示 git 的提交（commit）视图，一次次的提交形成一个可追溯、“有序”（当引入分支以后局部次序也会显得比较乱）的链条。&lt;/p&gt;

&lt;h2 id=&quot;git中的概念&quot;&gt;git中的概念&lt;/h2&gt;
&lt;p&gt;为了实现可追溯的链条，git 中包含了几个概念。&lt;/p&gt;

&lt;p&gt;大家可以看下面这张图，我们把上一张图里项目对应的 Git 仓库提交记录横过来展示了，现在左上角的这个躺着的是由一次次的提交记录组成的仓库。整个仓库直接保存在我们本地的磁盘上面，这个仓库可以来自于下面两种方式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/003_git_concepts_02.png&quot; alt=&quot;git命令图示&quot; title=&quot;Git命令及各环节流转&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;整个仓库可以来自于某个远端仓库，比如 github 里的 &lt;a href=&quot;https://github.com/chalver/book.git&quot;&gt;https://github.com/chalver/book.git&lt;/a&gt; 仓库，我们可以直接 &lt;code class=&quot;highlighter-rouge&quot;&gt;git clone remote-repository&lt;/code&gt; 到我们的本地；&lt;/li&gt;
  &lt;li&gt;除此之外呢我们也可以在我们的工作目录直接通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;git init&lt;/code&gt; 命令初始化一个本地的仓库。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;大家可以看到 workspace 就是我们正常编写内容的工作区域。当我们打开一个由 git 管理的项目的时候，里面可能已经包含了很多的代码，而且代码是以文件的形式分模块存在的。我们可能会在已有的某几个模块修改已有的函数或者提交几个新的函数，为了把我们修改的内容提交到 git 仓库，我们首先需要把我们的修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt; 到 stage 暂存空间，我们可以每修改一点内容都 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt; 到整个空间，从而为我们创建新的 commit 提交做准备。&lt;/p&gt;

&lt;p&gt;在 stage 空间，工作区域分散在各处的修改点被整合到一起。我们可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 命令查看 stage 空间里暂存的内容。&lt;/p&gt;

&lt;p&gt;当我们对工作区域的修改感到满意了，把内容全部添加到缓存区，那么我们就可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt; 来把我们的修改提交到本地仓库了。这里我们可以通过在 &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -m &quot;本次提交的内容&quot;&lt;/code&gt; 后添加注释来注明本地提交了什么内容。&lt;/p&gt;

&lt;p&gt;如果我们本地的仓库来自于一个远端仓库，或者我们本地初始化的仓库配置了对应的远端仓库，我们可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;git push&lt;/code&gt; 来把本地仓库的更新同步到远端仓库。&lt;/p&gt;

&lt;p&gt;当多人协作的时候，可能出现多人同时编写同一个仓库的情况，我们 &lt;code class=&quot;highlighter-rouge&quot;&gt;git push&lt;/code&gt; 本地仓库的时候可能远端的仓库已经被别人更新过了，此时我们就没有办法 push 仓库了。不过这个时候我们可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt; 来 merge 别人的更改，这样就可以继续 push 我们的代码到远端了。&lt;/p&gt;

&lt;p&gt;git 中还存在分支的概念，尤其在多人协作的时候尤其重要。不过这部分的内容比较复杂且对开发者的实践要求比较高，我会在后面的课程里再单独拎出来介绍。大家可以先尝试熟练掌握本节的内容。&lt;/p&gt;

&lt;h2 id=&quot;在-vscode-中使用-git&quot;&gt;在 vscode 中使用 git&lt;/h2&gt;

&lt;p&gt;vscode 天然集成了 git 环境，在安装 git 工具以后就可以通过左边的版本控制按钮来到对应的界面。&lt;/p&gt;

&lt;p&gt;我们可以通过 vscode 里提供的图形界面进行上面提到的各项操作，也可以在 vscode 的 terminal 里手动输入各个命令进行操作。&lt;/p&gt;

&lt;p&gt;我个人比较习惯通过命令行的方式操作，避免点错按钮（有的按钮挨着比较近，一个不小心可能导致自己丢失辛辛苦苦修改的内容）。大家可以根据喜好做选择，不过如果大家选择图形界面进行操作，建议大家多多练习一下，避免误操作导致不可挽回的损失=。=。&lt;/p&gt;

&lt;p&gt;大家可以通过查看 output 标签来查看图形界面每个操作的具体 git 命令，大家可以看到我们的一个按钮可能引发这么多的 git 命令的执行。里面有很多的命令可能是我们根本不会手动去敲的，因此不推荐大家去看它，不过在大家对 git 的感知到了某个境界以后，可以通过这里的内容进行探索，比如了解一下各个命令的实际作用，尝试打开另外一个世界的大门。&lt;/p&gt;

&lt;h3 id=&quot;通过图形界面实战&quot;&gt;通过图形界面实战&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;克隆 &lt;code class=&quot;highlighter-rouge&quot;&gt;https://github.com/chalvern/books.git&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;修改内容并添加到暂缓区&lt;/li&gt;
  &lt;li&gt;提交&lt;/li&gt;
  &lt;li&gt;推到远端&lt;/li&gt;
  &lt;li&gt;课堂展示2。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;通过命令行实战&quot;&gt;通过命令行实战&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git clone https://github.com/chalvern/books.git&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git add .&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -m &quot;add sth&quot;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git push&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;课堂展示。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;本文简单介绍了 git 的安装与初级使用，可至 &lt;a href=&quot;https://space.bilibili.com/425571569&quot;&gt;https://space.bilibili.com/425571569&lt;/a&gt; 查看对应的视频资料。&lt;/p&gt;

</description>
        <pubDate>Sun, 17 May 2020 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2020/05/17/git-installation-and-usage.html</link>
        <guid isPermaLink="true">https://jingwei.link/2020/05/17/git-installation-and-usage.html</guid>
        
        <category>课程</category>
        
        <category>基础</category>
        
        <category>实用</category>
        
        
        <category>课程</category>
        
      </item>
    
      <item>
        <title>《从0到1学习后端开发》之搭建 Linux 环境</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#写在前面&quot; id=&quot;markdown-toc-写在前面&quot;&gt;写在前面&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#初衷&quot; id=&quot;markdown-toc-初衷&quot;&gt;初衷&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#假如目前的你处于下面描述的处境&quot; id=&quot;markdown-toc-假如目前的你处于下面描述的处境&quot;&gt;假如目前的你处于下面描述的处境&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#获取-linux-环境的三种方式&quot; id=&quot;markdown-toc-获取-linux-环境的三种方式&quot;&gt;获取 Linux 环境的三种方式&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#虚拟机安装-linux-环境&quot; id=&quot;markdown-toc-虚拟机安装-linux-环境&quot;&gt;虚拟机安装 Linux 环境&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#windows-系统简单使用&quot; id=&quot;markdown-toc-windows-系统简单使用&quot;&gt;Windows 系统简单使用&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#安装虚拟机-virtualbox&quot; id=&quot;markdown-toc-安装虚拟机-virtualbox&quot;&gt;安装虚拟机 virtualBox&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#下载-ubuntu-镜像&quot; id=&quot;markdown-toc-下载-ubuntu-镜像&quot;&gt;下载 Ubuntu 镜像&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#在-virtualbox-安装-ubuntu-系统&quot; id=&quot;markdown-toc-在-virtualbox-安装-ubuntu-系统&quot;&gt;在 virtualBox 安装 Ubuntu 系统&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#ubuntu-系统熟悉&quot; id=&quot;markdown-toc-ubuntu-系统熟悉&quot;&gt;Ubuntu 系统熟悉&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#小结&quot; id=&quot;markdown-toc-小结&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;本文是《从0到1学习后端开发》的首篇教案文档。《从0到1学习后端开发》是面向在校大学生、非 IT 工作人员的后端开发入门实践教程，可至 &lt;a href=&quot;https://space.bilibili.com/425571569&quot;&gt;https://space.bilibili.com/425571569&lt;/a&gt; 查看对应的视频资料。&lt;/p&gt;

&lt;h2 id=&quot;初衷&quot;&gt;初衷&lt;/h2&gt;
&lt;p&gt;这一小节我们尝试搭建 Linux 环境。&lt;/p&gt;

&lt;p&gt;之所以搭建 Linux 环境，主要是因为太多的人只接触过 Windows 系统，没有接触过甚至不知道有 Linux 操作系统这件事情。而在我的认知里，后端开发者的基本技能之一就应该是能够使用 Linux 做一些基础的事情，比如查看/编辑文件、安装/配置应用、搭建/维护某种开发环境，等等。&lt;/p&gt;

&lt;p&gt;更为重要的，后端开发者编写的代码大概率是部署在 Linux 服务器上面的，和 Linux 靠的越近，意味着与代码的运行环境越近，写出优质代码的概率更高，排查线上问题的能力也会更好。&lt;/p&gt;

&lt;p&gt;论证使用 Linux 的好处并不是本教程的重点，本教程会假设大家已经意识到这一点，并正在尝试寻找一套靠谱的教程入门后端开发，那么选择本套教程就对了。即使未来因为各种原因本套视频进行不下去，也可以私下联系我（&lt;a href=&quot;https://jingwei.link&quot;&gt;个人主页&lt;/a&gt;，发个邮件总会的吧=。=)讨论各种问题。&lt;/p&gt;

&lt;h2 id=&quot;假如目前的你处于下面描述的处境&quot;&gt;假如目前的你处于下面描述的处境&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;有一台安装了 Windows 系统的电脑（笔记本或者台式机）；如果已经有 Linux 系统安装在物理机上面，或者财力雄厚有苹果电脑（类 Unix 系统，和 Linux 有相同的祖上），都可以直接跳到后面的内容去。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;想要学习后端开发的知识，尤其指 python 或者 Go 语言；这两个语言前者学习比较简单，后者比较流行，而本人主要在这两个技术栈，因此选定它们两个。如果想学习其他的语言，考虑到知识的迁移性，学习 python 和 Go 也会对自己学习其他语言有所帮助。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自律（比如不怎么睡懒觉）；我奶奶经常教育我们几个孙辈们说，“如果什么都不想去做，那就什么都不会获得”。想要生活改变必须自己首先改变，想学习知识必须要付出或者牺牲一些东西，大道理这里不讲太多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;到此，万事具备只欠一个 Linux 环境了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;获取-linux-环境的三种方式&quot;&gt;获取 Linux 环境的三种方式&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Linux 系统直接安装在物理机上面，就是说电脑开机后直接加载运行的就是 Linux 系统；&lt;/li&gt;
  &lt;li&gt;一个物理机上面安装了 Windows 系统和 Linux 系统（所谓的双系统）；&lt;/li&gt;
  &lt;li&gt;在虚拟机上安装 Linux 系统。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上面的三种方式各有利弊，&lt;/p&gt;

&lt;p&gt;第一种意味着你下了很大的决心学习使用 Linux，并且与 Windows 系统生态下的各种绚丽的应用（包括游戏）说了再见。&lt;/p&gt;

&lt;p&gt;第二种意味着你花了很多时间调研安装双系统的细节，并且很可能因为某些操作失误格式化过磁盘（数据丢失）。&lt;/p&gt;

&lt;p&gt;第三种最简单，但是意味着你的机器配置足够高（至少两个核四个线程，且 4G 以上的内存），而且还要忍受速率慢的问题。&lt;/p&gt;

&lt;p&gt;鉴于前两种的牺牲比较大，而本系列课程定位是入门，因此默认大家按照第三种的方式进行学习，可以学习一定时间找到感觉以后再考虑另外两种方式。&lt;/p&gt;

&lt;h2 id=&quot;虚拟机安装-linux-环境&quot;&gt;虚拟机安装 Linux 环境&lt;/h2&gt;

&lt;h3 id=&quot;windows-系统简单使用&quot;&gt;Windows 系统简单使用&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;桌面整理，把用户文件夹调整出来放桌面上面；&lt;/li&gt;
  &lt;li&gt;查看系统配置；&lt;/li&gt;
  &lt;li&gt;安装/卸载软件；&lt;/li&gt;
  &lt;li&gt;调整启动项；&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;安装虚拟机-virtualbox&quot;&gt;安装虚拟机 virtualBox&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;下载 virtualBox 虚拟机；通过搜索引擎查找到官方网站的下载地址并下载安装包。&lt;/li&gt;
  &lt;li&gt;根据安装包进行安装。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;下载-ubuntu-镜像&quot;&gt;下载 Ubuntu 镜像&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;认识 Ubuntu 官网；&lt;/li&gt;
  &lt;li&gt;认识 “开源镜像站”；&lt;/li&gt;
  &lt;li&gt;下载 ubuntu-18.04 版本&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;在-virtualbox-安装-ubuntu-系统&quot;&gt;在 virtualBox 安装 Ubuntu 系统&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;新建实例，并配置；&lt;/li&gt;
  &lt;li&gt;安装界面；&lt;/li&gt;
  &lt;li&gt;启动&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;ubuntu-系统熟悉&quot;&gt;Ubuntu 系统熟悉&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;启动关机按钮&lt;/li&gt;
  &lt;li&gt;基本信息&lt;/li&gt;
  &lt;li&gt;查看快捷方式，并打开 terminal&lt;/li&gt;
  &lt;li&gt;认识并调整设置 terminal 的快捷键&lt;/li&gt;
  &lt;li&gt;认识应用列表&lt;/li&gt;
  &lt;li&gt;认识软件商城，并安装一个软件（VLC）&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;本节课程主要带领大家在虚拟机上面安装 Ubuntu（Linux）操作系统，可至 &lt;a href=&quot;https://space.bilibili.com/425571569&quot;&gt;https://space.bilibili.com/425571569&lt;/a&gt; 查看对应的视频资料。&lt;/p&gt;

</description>
        <pubDate>Sat, 16 May 2020 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2020/05/16/install-ubuntu-on-virtualbox.html</link>
        <guid isPermaLink="true">https://jingwei.link/2020/05/16/install-ubuntu-on-virtualbox.html</guid>
        
        <category>课程</category>
        
        <category>基础</category>
        
        <category>实用</category>
        
        
        <category>课程</category>
        
      </item>
    
      <item>
        <title>学习在一朝一夕，更在长长久久</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#坚持下去的理由与动力&quot; id=&quot;markdown-toc-坚持下去的理由与动力&quot;&gt;坚持下去的理由与动力&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#应该学什么&quot; id=&quot;markdown-toc-应该学什么&quot;&gt;应该学什么&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#如何坚持学习&quot; id=&quot;markdown-toc-如何坚持学习&quot;&gt;如何坚持学习&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;思考一下，我们在自己的技术栈里是否每天都有提升？&lt;/p&gt;

&lt;h2 id=&quot;坚持下去的理由与动力&quot;&gt;坚持下去的理由与动力&lt;/h2&gt;

&lt;p&gt;平时的生活里，不知不觉就懈怠了。&lt;/p&gt;

&lt;p&gt;可怕的是自己意识不到这种懈怠，甚至有时候还把“仰望星空/思考人生”作为懈怠的理由堂而皇之地颓废自己。&lt;/p&gt;

&lt;p&gt;如果我们接受自己一生平庸，那么生活处于懈怠的常态也无可厚非。但是大部分人对自己的生活都是有诉求的，而且在自己当前的诉求得到满足之后还会衍生出另外的诉求（人贪婪的本性）。&lt;/p&gt;

&lt;p&gt;有时候我就会感慨，如果之前的岁月里（每天/每周/每月/每年）做了某件事情，那么现在的自己该有多么厉害。这种感慨说明当前的自己知道了需要的技能，但是对当下状况的改善几乎无济于事。不过反过来想，&lt;strong&gt;如果能够预判到未来自己的短板或需要的技能，是不是现在就可以（每天/每周/每月/每年）做某件事情准备起来呢&lt;/strong&gt;？&lt;/p&gt;

&lt;p&gt;那么未来的自己需要哪些技能？&lt;/p&gt;

&lt;h2 id=&quot;应该学什么&quot;&gt;应该学什么&lt;/h2&gt;

&lt;p&gt;如果知道自己需要的技能，并且清楚掌握这些技能所要学习的教材、书籍、文档等，技能的提升一般是很“迅猛”的。&lt;/p&gt;

&lt;p&gt;难点在于&lt;strong&gt;大部分时候我们不清楚自己需要什么技能&lt;/strong&gt;，不清楚应该学习哪本教材、书籍，不清楚应该阅读什么文档、源码。针对这种情况，笔者根据自己的经验总结出下面几个点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;想一想自己期望的营生方式，以及在这种营生方式下具体的工作内容是什么，从而确定自己所需技能的范畴领域；&lt;/li&gt;
  &lt;li&gt;确定技能领域后，①有条件的情况下锁定一个领路人（比如工作上以学徒的方式向有经验的人学习）②没有条件的情况下，从最基础的官方教程开始自行学习，这里强调以官方教程入手，避免被带偏；&lt;/li&gt;
  &lt;li&gt;坚持学习 10000+ 个小时。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;如何坚持学习&quot;&gt;如何坚持学习&lt;/h2&gt;

&lt;p&gt;阻碍学习的两个拦路障：一个是无知，也就是不知道自己应该学习什么（可以参照上一小节的内容）；另一个是懒惰——人的另一个本性。&lt;/p&gt;

&lt;p&gt;首先应该提一个老少皆宜的大道理：&lt;strong&gt;不努力学习，能力是不会稳定提升的；不持续学习，个人也会局限在某个特定的水平&lt;/strong&gt;。因此”如何坚持学习“就变成了如何克服懒惰的本性。&lt;/p&gt;

&lt;p&gt;根据经验，不妨从一个简单的习惯开始：比如坚持每天跑 1000 米，比如坚持每天做 20 个俯卧撑，比如坚持每天做 50 个仰卧起坐，再比如坚持每天温习一首古诗词，或者坚持每天背诵一个英文单词…… 坚持做一件简单又无聊的事情的价值是什么呢？除去身体素质和精神境界上的提升（哪怕是微弱的），还可以&lt;strong&gt;逐渐养成自律与坚持的品质&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自律与坚持&lt;/strong&gt;在成年人世界里是两个非常稀缺的品质。如果想培养这两种品质，总要付出一些东西；可能是少放松几局游戏，可能是少仰望一会儿星空，还可能是少睡几刻钟……&lt;/p&gt;

&lt;p&gt;总之，耐心地磨时间吧。没有其他的捷径。&lt;/p&gt;

</description>
        <pubDate>Sat, 25 Apr 2020 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2020/04/25/learning-is-long-journey.html</link>
        <guid isPermaLink="true">https://jingwei.link/2020/04/25/learning-is-long-journey.html</guid>
        
        <category>碎碎念</category>
        
        <category>基础</category>
        
        <category>实用</category>
        
        
        <category>碎碎念</category>
        
      </item>
    
      <item>
        <title>人生苦短，快用 Python</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#1-写在前面&quot; id=&quot;markdown-toc-1-写在前面&quot;&gt;1. 写在前面&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-编程语言是为业务场景服务的&quot; id=&quot;markdown-toc-2-编程语言是为业务场景服务的&quot;&gt;2. 编程语言是为业务场景服务的&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#21-静态语言与动态语言&quot; id=&quot;markdown-toc-21-静态语言与动态语言&quot;&gt;2.1 静态语言与动态语言&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#211-静态语言的编写-编译并链接-执行过程&quot; id=&quot;markdown-toc-211-静态语言的编写-编译并链接-执行过程&quot;&gt;2.1.1 静态语言的①编写-②编译并链接-③执行过程&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#212-动态语言的编写-解释执行过程&quot; id=&quot;markdown-toc-212-动态语言的编写-解释执行过程&quot;&gt;2.1.2 动态语言的①编写-②解释执行过程&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#22-人生苦短快用python&quot; id=&quot;markdown-toc-22-人生苦短快用python&quot;&gt;2.2 人生苦短，快用Python&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-小结&quot; id=&quot;markdown-toc-3-小结&quot;&gt;3 小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;1-写在前面&quot;&gt;1. 写在前面&lt;/h2&gt;

&lt;p&gt;从 &lt;a href=&quot;https://www.ruby-lang.org/&quot;&gt;Ruby&lt;/a&gt; 语言到 &lt;a href=&quot;https://golang.google.cn/&quot;&gt;Go&lt;/a&gt; 语言，目前终于开始使用 &lt;a href=&quot;https://www.python.org/&quot;&gt;Python&lt;/a&gt; 进行编码。&lt;/p&gt;

&lt;p&gt;对于&lt;strong&gt;职场新手&lt;/strong&gt;，可能首先会提出一个问题：难道 &lt;strong&gt;Ruby&lt;/strong&gt;/&lt;strong&gt;Go&lt;/strong&gt; 不香吗？难道 &lt;strong&gt;Python&lt;/strong&gt; 比其他两个语言好？其实都不是。如果我们认同&lt;strong&gt;“技术是为业务服务的”&lt;/strong&gt;这个论调，那么&lt;strong&gt;“编程语言应该为业务场景服务”&lt;/strong&gt;，仅此而已。&lt;/p&gt;

&lt;h2 id=&quot;2-编程语言是为业务场景服务的&quot;&gt;2. 编程语言是为业务场景服务的&lt;/h2&gt;

&lt;p&gt;根据业务场景选择合适的编程语言，使得当前场景的开发收益最大化。当用户量不是很多（机器没什么压力）而业务逻辑却比较繁杂（开发者编码有压力）的情况下，使用 Python 编码或许是一个较为明智的选择。&lt;/p&gt;

&lt;h3 id=&quot;21-静态语言与动态语言&quot;&gt;2.1 静态语言与动态语言&lt;/h3&gt;

&lt;p&gt;所谓静态语言，是指代码在编译的时候（简称&lt;strong&gt;编译时&lt;/strong&gt;）变量的类型就可以确定的语言，比如 C/C++、Java、Go、Object-C 等；所谓静态语言，是指代码在运行的时候（简称&lt;strong&gt;运行时&lt;/strong&gt;）变量的类型才可以确定的语言，比如 Python、Ruby、JavaScript、PHP、SQL等。&lt;/p&gt;

&lt;p&gt;进一步，所以&lt;strong&gt;编译时&lt;/strong&gt;，是指把代码文本转换为机器可执行文件的环境上下文，它会&lt;strong&gt;产出&lt;/strong&gt;一个机器可以执行的二进制文件。所谓&lt;strong&gt;运行时&lt;/strong&gt;，是指可执行的二进制文件在 CPU 上真实执行的上下文。&lt;/p&gt;

&lt;h4 id=&quot;211-静态语言的编写-编译并链接-执行过程&quot;&gt;2.1.1 静态语言的①编写-②编译并链接-③执行过程&lt;/h4&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// cat main.go&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello world&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们使用 Go &lt;strong&gt;编写&lt;/strong&gt;业务逻辑（比如上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;hello world&lt;/code&gt;代码）并执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;go run main.go&lt;/code&gt; 的时候，Go 开发工具链隐含地帮我们首先&lt;strong&gt;编译并链接源码&lt;/strong&gt;生成可以执行的二进制文件，紧接着&lt;strong&gt;运行&lt;/strong&gt;这个二进制文件。也就是说，&lt;code class=&quot;highlighter-rouge&quot;&gt;go run main.go&lt;/code&gt; 等效于 ①&lt;code class=&quot;highlighter-rouge&quot;&gt;go build main.go&lt;/code&gt; + ②&lt;code class=&quot;highlighter-rouge&quot;&gt;./mian&lt;/code&gt; 这两个命令操作。&lt;/p&gt;

&lt;p&gt;我们可以简单地认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;go build main.go&lt;/code&gt; 是 Go 代码的编译时，产物是一个可执行的二进制文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;；命令&lt;code class=&quot;highlighter-rouge&quot;&gt;./main&lt;/code&gt; 是 Go 代码的运行时，此时我们编写的逻辑&lt;em&gt;开始&lt;/em&gt;在 CPU 上执行。&lt;/p&gt;

&lt;h4 id=&quot;212-动态语言的编写-解释执行过程&quot;&gt;2.1.2 动态语言的①编写-②解释执行过程&lt;/h4&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# cat hello.py
&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello world&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当我们使用 Python &lt;strong&gt;编写&lt;/strong&gt;业务逻辑(比如上面的代码)，在执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;python hello.py&lt;/code&gt; 的时候，Python 解释器直接帮我们&lt;strong&gt;解释并执行&lt;/strong&gt;业务逻辑。由于人与机器之间的隔阂，python 源码最终也要变成机器可以执行的代码；但是相对于静态语言，&lt;strong&gt;动态语言不存在编译后机器可执行的二进制产物&lt;/strong&gt;。换句话说，Python 的解释器一边编译源码，一边执行编译生成的代码。&lt;/p&gt;

&lt;h3 id=&quot;22-人生苦短快用python&quot;&gt;2.2 人生苦短，快用Python&lt;/h3&gt;

&lt;p&gt;仅仅缺省编译链接过程并不能成为选择动态语言 Python 的理由，原因很简单：但凡使用 Python 能够解决的问题，均可以使用其他非 Python 的方案解决。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;我们可以使用 Python 处理文件（重命名、修改内容），也可以使用 Go 或者 Java 等完成同样的任务；&lt;/li&gt;
  &lt;li&gt;我们可以使用 Python 处理表格数据，也可以使用 Go 或者 Java 等处理表格数据并达到同样的效果；&lt;/li&gt;
  &lt;li&gt;我们可以使用 Python 编写爬虫工具，也可以使用 GO 或者 Java 等实现爬虫工具；&lt;/li&gt;
  &lt;li&gt;我们可以使用 Python 编写 Web 服务，而使用 Go 或者 Java 等也可以编写 Web 服务甚至生态更完整；&lt;/li&gt;
  &lt;li&gt;我们可以使用 Python 实践 AI 算法，而其他的语言也可以完成类似的工作（只不过生态不如 Python）；&lt;/li&gt;
  &lt;li&gt;其他……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于上面的事实，并不存在必学 Python 的理由。可能 Python 只是一些细节上让完成上面列出的任务更简单，比如文件的读取、类型的转换（字符串与数字的互转）、序列号与反序列化（json字符串与json对象之间互转），等等；Python 语言本身封装了一些工具方法很容易地完成这些事情，而 Python 的第三方包进一步扩展了整个生态。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Python 可以更简单地处理文件（重命名、修改内容），比如几行代码就可以实现文件的打开、读取、写入、关闭；&lt;/li&gt;
  &lt;li&gt;Python 可以更快地处理表格数据，比如可以方便地循环迭代每一行每一个格子，也可以很方便地对表格数据进行格式转换；&lt;/li&gt;
  &lt;li&gt;Python 可以更快地处理爬取到的数据，比如可以方便地把 json 字符串转换成为 json 对象进行进一步的处理；&lt;/li&gt;
  &lt;li&gt;Python 在 AI 算法实践领域几乎是霸权地位（因为那些懂算法的人更喜欢写 Python 代码），使得 Python 技术栈几乎包含了所有 AI 相关的算法；&lt;/li&gt;
  &lt;li&gt;其他……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于上面的考虑，其实可以尝试学一下 Python。&lt;/p&gt;

&lt;h2 id=&quot;3-小结&quot;&gt;3 小结&lt;/h2&gt;

&lt;p&gt;因为 Python 提供的一些便利性，当用户量不是很多（机器没什么压力）而业务逻辑却比较繁杂（开发者编码有压力）的情况下，使用 Python 编码是一个较为明智的选择：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;释放开发者把注意力放在业务逻辑的理解与梳理；&lt;/li&gt;
  &lt;li&gt;很容易地扩充编码队伍（容易培养或招纳新成员）.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 18 Apr 2020 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2020/04/18/use-python-quickly.html</link>
        <guid isPermaLink="true">https://jingwei.link/2020/04/18/use-python-quickly.html</guid>
        
        <category>python</category>
        
        <category>基础</category>
        
        <category>实用</category>
        
        
        <category>编程</category>
        
      </item>
    
      <item>
        <title>职场人士应该学什么以及学习方法（编码领域）</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#写在前面&quot; id=&quot;markdown-toc-写在前面&quot;&gt;写在前面&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#知识的不同层级&quot; id=&quot;markdown-toc-知识的不同层级&quot;&gt;知识的不同层级&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#自己应该学习什么&quot; id=&quot;markdown-toc-自己应该学习什么&quot;&gt;自己应该学习什么&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#知识的分类应该怎么学&quot; id=&quot;markdown-toc-知识的分类应该怎么学&quot;&gt;知识的分类（应该怎么学）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#小结&quot; id=&quot;markdown-toc-小结&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;俗话说，“活到老学到老”。对程序员而言，尤其如此；或者说的严重一点，程序员唯有此一条路。然而，无论是职场新人还是职场老手，能够坚持学习的人却凤毛麟角。一方面是因为&lt;strong&gt;坚持学习&lt;/strong&gt;需要很强的毅力，而人有偷懒的劣根在；另一方面则是因为学习目标模糊，不知道该学什么，也不知道该怎么学。&lt;/p&gt;

&lt;p&gt;如果把坚持学习看做一个习惯，如何培养这个习惯本文不做讨论，大家可以先自行思考；本文只尝试分析知识的层级，从而便于我们认清&lt;strong&gt;自己应该学习什么以及应该怎么学习&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;知识的不同层级&quot;&gt;知识的不同层级&lt;/h2&gt;

&lt;p&gt;假设任何领域的知识分为不同的层级。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
（↑实践）
&lt;span class=&quot;c&quot;&gt;############################################################&lt;/span&gt;
L3 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;domain knowlege&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;     | L3-1 | L3-2  |  |  L3-3 | L3-4 | 
&lt;span class=&quot;c&quot;&gt;#########################|##############|##|##############|#&lt;/span&gt;
L2 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;practice knowledge&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  |    L2-1      |  |     L2-2     | 
&lt;span class=&quot;c&quot;&gt;############################################################&lt;/span&gt;
L1 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;general knowlege&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;###################################&lt;/span&gt;
L0（low-level knowledge&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;###########################&lt;/span&gt;
（↓理论）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;（某个领域的知识等级图）&lt;/p&gt;

&lt;p&gt;L0 代表&lt;strong&gt;底层基础层&lt;/strong&gt;，表示那些比较少涉及到的知识；L1 代表&lt;strong&gt;通用知识层&lt;/strong&gt;，表示只要涉及当前领域的工作就需要掌握的基础知识；L2 代表&lt;strong&gt;实践层&lt;/strong&gt;，这个层级的知识开始出现领域上的初步分化；L3 代表&lt;strong&gt;领域层&lt;/strong&gt;，包含更为专业的领域知识。越往下面越偏向理论，越往上面越偏向实践。直白地理解，越往下越接近课堂里学习到的知识，越往上越接近工作中用到的知识。&lt;/p&gt;

&lt;p&gt;作为一名编码者，理想情况下需要从 L0 到 L3 逐一训练自己的能力。但是在精力限制以及时间限制的情况下，无法顾全所有，只能有选择性地进行学习。&lt;/p&gt;

&lt;h3 id=&quot;自己应该学习什么&quot;&gt;自己应该学习什么&lt;/h3&gt;

&lt;p&gt;在讨论知识的时候，庄子曾讲“吾生也有涯，而知也无涯”，那么多知识根本学习不完；这对于学习者来说算是&lt;strong&gt;一个坏消息&lt;/strong&gt;。但是并不意味着放弃学习是一件睿智的选择（其实放弃学习是很愚蠢的选择），因为还有一个事实，解决工作上的实际问题并不需要所有的知识，有时候解决一个问题只需要掌握一小块知识就足够了；这对于学习者来说算是&lt;strong&gt;一个好消息&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;自己应该学习什么？如果目前工作中需要某个技能，但是自己不具备这个技能，投入时间精力学习吧！如果自己未来的工作中（工作转型）需要某个技能，但是自己目前不具备这个技能，也投入时间学习吧！&lt;/p&gt;

&lt;p&gt;如果自己不知道当前的工作需要哪个技能，也不知道自己未来的工作需要哪个技能，说明自己处于迷茫阶段，不妨尝试一些别的事情。对于非 IT 领域的同学，可以尝试学习一门编程语言；对于已经是 IT 领域的同学，可以尝试通读一下某个编程语言的手册文档；等等。&lt;/p&gt;

&lt;h3 id=&quot;知识的分类应该怎么学&quot;&gt;知识的分类（应该怎么学）&lt;/h3&gt;

&lt;p&gt;根据我的学习经历及工作经验，我发现基本上可以把知识分成下面几类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;死记硬背型的知识点（比如九九乘法口诀）&lt;/li&gt;
  &lt;li&gt;系统理论型的知识点（比如乘法竖列式）&lt;/li&gt;
  &lt;li&gt;一系列的知识点形成的领域栈只是（比如仅 python 技术栈包含了成百上千个知识点）&lt;/li&gt;
  &lt;li&gt;只有经历过才会有的知识（也就是一般所说的经验）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这四类里面，死记硬背型的知识点需要花费时间进行记忆，如果记忆力比较好短时间可以掌握；系统理论型的知识点主要凭借逻辑思维能力进行学习，如果理解能力好也可以短时间内掌握。但是接下来的&lt;strong&gt;领域栈知识和经验知识都需要时间上的打磨&lt;/strong&gt;，尤其经验，没有时间上的积累几乎是不可能有成绩的。&lt;/p&gt;

&lt;p&gt;如果读者朋友已结束学生时代并步入社会，或许已经意识到：很多聪明的小孩子认为凭借自己的聪明才智可以很容易地收获知识，从而不付出努力进行学习，这是一件愚蠢的行为。有的知识本就是耗精力耗时的性质，没有捷径真正掌握它。&lt;/p&gt;

&lt;p&gt;如果&lt;strong&gt;确认了自己应该学习的领域栈，不遗余力地学习这个领域栈的知识点，然后想尽一切办法实践这些知识点吧&lt;/strong&gt;！&lt;/p&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;本文属于理论上的罗列，希望读者反思自己学习的过程，理解为何有的知识学起来简单而有的知识学起来那么难，同时希望读者反思所学内容对自己职业生涯的意义。&lt;/p&gt;
</description>
        <pubDate>Sun, 05 Apr 2020 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2020/04/05/learning-methodology.html</link>
        <guid isPermaLink="true">https://jingwei.link/2020/04/05/learning-methodology.html</guid>
        
        <category>基础</category>
        
        <category>实用</category>
        
        
        <category>编程</category>
        
      </item>
    
      <item>
        <title>如何为 Go 语言源码仓库贡献代码</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#写在前面&quot; id=&quot;markdown-toc-写在前面&quot;&gt;写在前面&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#为-go-语言源码仓库贡献代码&quot; id=&quot;markdown-toc-为-go-语言源码仓库贡献代码&quot;&gt;为 Go 语言源码仓库贡献代码&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#我们往往忽略了官方材料的学习&quot; id=&quot;markdown-toc-我们往往忽略了官方材料的学习&quot;&gt;我们往往忽略了官方材料的学习&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#如何为-go-语言源码仓库贡献代码&quot; id=&quot;markdown-toc-如何为-go-语言源码仓库贡献代码&quot;&gt;如何为 Go 语言源码仓库贡献代码&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#小结&quot; id=&quot;markdown-toc-小结&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;二零一九年（2019）利用业余的时间做了一套&lt;a href=&quot;https://github.com/chalvern/books/tree/master/go/official_go_learning&quot;&gt;《原汁原味Go语言学习》&lt;/a&gt;的视频课程，主要涉及到 Go 官方的几个文档资料的学习。在翻译官方文档的过程中发现有一处错误（前前后后看了很多遍，每次看到都觉得不爽），调研后发现是 Go 源码仓库中的文档，于是心血来潮修正错误并提交了 commit，私心里还琢磨着如果代码被合并自己以后岂不就可以吹嘘是&lt;strong&gt;Go语言源码的贡献者&lt;/strong&gt;了？&lt;/p&gt;

&lt;p&gt;按照官方指引，春节放假前提交修正并得到管理员的正反馈，然后一直关注了好久但不见代码被合并，一度以为自己的这个提交被忽略了，不过最近看到已经被合并到了&lt;a href=&quot;https://github.com/golang/go/commit/34830beffa6396129bd9d9da58afb7a046775d49&quot;&gt;Go主分支&lt;/a&gt;。开心😸。&lt;/p&gt;

&lt;p&gt;其实整个提交过程还是比较流畅的，现在简单总结记录一下供自己以及他人参考。&lt;/p&gt;

&lt;h2 id=&quot;为-go-语言源码仓库贡献代码&quot;&gt;为 Go 语言源码仓库贡献代码&lt;/h2&gt;

&lt;h3 id=&quot;我们往往忽略了官方材料的学习&quot;&gt;我们往往忽略了官方材料的学习&lt;/h3&gt;

&lt;p&gt;由于每个人学习编程的方式不同，可能无法评估出编程的最佳学习方式；但是作为熟练程度的基准，语言的官方文档理应是其最佳的学习资料。以 Go 语言为例，可能市面上存在很多 Go 语言相关的书籍，但是任何一本书都无法让自己精通 Go 语言编程（如果有类似标榜的书籍，千万不要买）；从这个角度讲，书籍只能作为编程语言学习的指引者——激起学习者的学习热情，启发学习者的学习路径——其他的技术细节和技巧仍然需要学习者自己去探索体会。&lt;/p&gt;

&lt;p&gt;不过虽说编程语言的官方文档是最佳的学习资料，但是官方文档往往是枯燥无趣的，因此也难怪很多人都不喜欢读。可是，编程语言的学习与掌握本就是一个枯燥无趣的过程，又有什么办法……&lt;/p&gt;

&lt;h3 id=&quot;如何为-go-语言源码仓库贡献代码&quot;&gt;如何为 Go 语言源码仓库贡献代码&lt;/h3&gt;

&lt;p&gt;只需参考 《&lt;a href=&quot;https://golang.google.cn/doc/contribute.html&quot;&gt;Contribution Guide 官方文档&lt;/a&gt;》即可。&lt;/p&gt;

&lt;p&gt;大家可以看到整个文档都是英文资料，且在提交代码让别人审核的过程中也都是英文沟通交流，因此这里关键的点或许是把英文学好……&lt;/p&gt;

&lt;p&gt;从我个人的经验看，只要英文够好，确实发现了源码中不合理的地方，又觉得自己有好点子，都可以为 Go 语言贡献代码。为了破除大家对提交代码这件事情的神秘感，这里简单罗列一下&lt;a href=&quot;https://golang.google.cn/doc/contribute.html&quot;&gt;官方文档&lt;/a&gt;里介绍的几个点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先准备好账户并签署贡献者协议（Google账户、Gerrit账户）；&lt;/li&gt;
  &lt;li&gt;配置自己本地的环境（配置 git、配置 gerrit，后者是谷歌官方提供的一个小工具，可以保持自己的 commit 信息的规范）；&lt;/li&gt;
  &lt;li&gt;修改完代码后就可以使用 gerrit 提交了;&lt;/li&gt;
  &lt;li&gt;提交完成后到 https://go.googlesource.com/ 可以观察进度，甚至可能需要根据修改意见进行内容上的阐述、修改等；&lt;/li&gt;
  &lt;li&gt;等提交的内容被完全认同以后，剩下的就是耐心等着被合并到 Master 主分支了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;自己的代码被合并到主仓库，好像这份开心慢慢地也消散了。终于还是要踏踏实实地解决业务问题，如此自己的创造才是有价值的。&lt;/p&gt;

</description>
        <pubDate>Sun, 15 Mar 2020 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2020/03/15/contribute_golang_process.html</link>
        <guid isPermaLink="true">https://jingwei.link/2020/03/15/contribute_golang_process.html</guid>
        
        <category>golang</category>
        
        <category>最佳实践</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>更实用的 Go 开发的社区论坛——apollo 开源项目介绍</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#apollo-项目&quot; id=&quot;markdown-toc-apollo-项目&quot;&gt;apollo 项目&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#使用到的库或框架&quot; id=&quot;markdown-toc-使用到的库或框架&quot;&gt;使用到的库（或框架）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#安装运行&quot; id=&quot;markdown-toc-安装运行&quot;&gt;安装运行&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#环境要求&quot; id=&quot;markdown-toc-环境要求&quot;&gt;环境要求&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#详细步骤&quot; id=&quot;markdown-toc-详细步骤&quot;&gt;详细步骤&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#其他资料&quot; id=&quot;markdown-toc-其他资料&quot;&gt;其他资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;apollo-项目&quot;&gt;apollo 项目&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/chalvern/apollo&quot;&gt;apollo&lt;/a&gt; 项目的主体是一个 go 语言原生的 bbs 社区系统，主要为了弥补当前 go 语言原生社区系统的空白。在前后端分离盛行的今天，越来越多的技术细节被默认存在，无形中也就增加了初学者在这个技术栈的学习门槛。&lt;a href=&quot;https://github.com/chalvern/apollo&quot;&gt;apollo&lt;/a&gt; 项目专注在 go 技术栈，从命令行启动、配置读取，到数据库访问、html模板渲染，均直接采用了 go 对应的库；除了语言层面的学习，&lt;a href=&quot;https://github.com/chalvern/apollo&quot;&gt;apollo&lt;/a&gt; 项目还抽象了一些 web 设计中可能涉及的基本点，从而便于初学者未来了解设计更为宏大的项目。&lt;/p&gt;

&lt;p&gt;由于经验尚浅，再加上时间因素约束，项目中难免有一些不雅的设计，欢迎大家创建 issue 指出问题，并欢迎大家提交更为完善的代码。&lt;/p&gt;

&lt;p&gt;设计细节请查看 &lt;a href=&quot;https://github.com/chalvern/apollo/tree/master/wiki&quot;&gt;wiki&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;使用到的库或框架&quot;&gt;使用到的库（或框架）&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;web——&lt;a href=&quot;https://github.com/gin-gonic/gin&quot;&gt;gin&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;ORM——&lt;a href=&quot;https://github.com/jinzhu/gorm&quot;&gt;gorm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;日志——&lt;a href=&quot;https://github.com/uber-go/zap&quot;&gt;uber/zap&lt;/a&gt;/&lt;a href=&quot;https://github.com/chalvern/sugar&quot;&gt;sugar&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;配置——&lt;a href=&quot;https://github.com/spf13/viper&quot;&gt;viper&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;其他可参考 &lt;a href=&quot;../go.mod&quot;&gt;go.mod&lt;/a&gt; 文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;安装运行&quot;&gt;安装运行&lt;/h1&gt;

&lt;p&gt;apollo 是一个功能轻完备的项目，目前它已具备注册、登陆、注销、发帖、编辑、回复等功能，可以在一些简单应用场景下使用。可以到 http://www.jianzhoubian.com) 预览，测试好像只能使用 http 协议而不能使用 https 协议访问=。=&lt;/p&gt;

&lt;h2 id=&quot;环境要求&quot;&gt;环境要求&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;安装 go（version &amp;gt;= 1.13）&lt;/li&gt;
  &lt;li&gt;安装 MySQL（apollo 使用了 5.7.28 进行的开发)&lt;/li&gt;
  &lt;li&gt;（可选）安装 make (Linux 和 MacOS 上默认应该都有)，如果没有安装，则需要手动运行一些命令&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;详细步骤&quot;&gt;详细步骤&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;下载本仓库的代码(后面的操作都是在项目目录下执行)；&lt;/li&gt;
  &lt;li&gt;根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;configs/config.yml.example&lt;/code&gt; 创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;configs/config.yml&lt;/code&gt; 文件；&lt;/li&gt;
  &lt;li&gt;根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;configs/config.yml&lt;/code&gt; 中数据库（database）的配置，在 MySQL 中创建用户及数据库。下面以 &lt;code class=&quot;highlighter-rouge&quot;&gt;apollo&lt;/code&gt; 为例&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 创建 apollo 数据库，默认字符集为 utf8mb4&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DATABASE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`apollo`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`utf8mb4`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- 创建用户名为 jingwei 密码为 20200101 的用户，并赋权 apollo 的所有权限给 jingwei&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GRANT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ALL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRIVILEGES&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apollo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jingwei&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&quot;%&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDENTIFIED&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&quot;20200101&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;迁移数据表结构：&lt;/p&gt;

    &lt;p&gt;1.1 如果安装了 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 工具，直接运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;make migrate&lt;/code&gt; 即可完成数据表的迁移。&lt;/p&gt;

    &lt;p&gt;1.2 如果没有安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 工具，依次执行：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 下载依赖&lt;/span&gt;
go mod tidy
&lt;span class=&quot;c&quot;&gt;# 构建 apollo.exe 二进制执行文件&lt;/span&gt;
go build &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; apollo.exe main.go

&lt;span class=&quot;c&quot;&gt;# 执行迁移&lt;/span&gt;
./apollo.exe migrate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;通过命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;./apollo.exe&lt;/code&gt; 运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;apollo&lt;/code&gt; 项目。&lt;/li&gt;
  &lt;li&gt;通过浏览器访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost:2020&lt;/code&gt; 即可看到对应的页面。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;其他资料&quot;&gt;其他资料&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/av86199253&quot;&gt;视频介绍&lt;/a&gt; 【原汁原味go语言学习】(14) 实践篇之 apollo 开源项目介绍&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 08 Feb 2020 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2020/02/08/appolo-go-web-blog.html</link>
        <guid isPermaLink="true">https://jingwei.link/2020/02/08/appolo-go-web-blog.html</guid>
        
        <category>golang</category>
        
        <category>实用</category>
        
        <category>最佳实践</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>为团队寻找后端开发工程师（招聘）</title>
        <description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;程序员是“活到老学到老”的践行者，无论是前端开发者还是后端开发者，都是如此。希望你也是这样的程序员。&lt;/p&gt;

&lt;p&gt;在加入当前的公司（&lt;strong&gt;上海·桂林路&lt;/strong&gt;）后，随着公司业务逐渐展开，发现团队里的事情也多起来了，因此开贴找一起共事一起学习的同事。&lt;/p&gt;

&lt;h2 id=&quot;后端开发工程师&quot;&gt;后端开发工程师&lt;/h2&gt;

&lt;p&gt;职位描述：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;参与完成项目的系统分析、设计，并负责业务功能与底层基础功能的功能设计、代码实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;希望你：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;有 2 年以上的后端开发经验；&lt;/li&gt;
  &lt;li&gt;熟练使用 Java/Go/Python 中的一种或多种编程语言；&lt;/li&gt;
  &lt;li&gt;了解并能熟练使用常见的数据库（Mysql、ElasticSearch、MongoDB、Redis 等）；&lt;/li&gt;
  &lt;li&gt;掌握计算机基本理论知识，包括基础网络、存储、算法等；&lt;/li&gt;
  &lt;li&gt;如果自我感觉良好，可以不受上面条款的限制。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;欢迎邮件（zhjw43@163.com）骚扰。&lt;/p&gt;
</description>
        <pubDate>Fri, 03 Jan 2020 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2020/01/03/you-can-be-my-coworker.html</link>
        <guid isPermaLink="true">https://jingwei.link/2020/01/03/you-can-be-my-coworker.html</guid>
        
        <category>管理</category>
        
        <category>实用</category>
        
        
        <category>管理</category>
        
      </item>
    
      <item>
        <title>《原汁原味 Go 语言学习》(13) Go 内存模型</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#资料&quot; id=&quot;markdown-toc-资料&quot;&gt;资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#简介introduction&quot; id=&quot;markdown-toc-简介introduction&quot;&gt;简介（Introduction）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#建议advice&quot; id=&quot;markdown-toc-建议advice&quot;&gt;建议（Advice）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#发生在之前happens-before&quot; id=&quot;markdown-toc-发生在之前happens-before&quot;&gt;发生在…之前（Happens Before）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#同步化synchronization&quot; id=&quot;markdown-toc-同步化synchronization&quot;&gt;同步化（Synchronization）&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#初始化&quot; id=&quot;markdown-toc-初始化&quot;&gt;初始化&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#go协程的创建&quot; id=&quot;markdown-toc-go协程的创建&quot;&gt;Go协程的创建&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#go协程的销毁&quot; id=&quot;markdown-toc-go协程的销毁&quot;&gt;Go协程的销毁&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#信道通信&quot; id=&quot;markdown-toc-信道通信&quot;&gt;信道通信&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#锁&quot; id=&quot;markdown-toc-锁&quot;&gt;锁&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#单次运行&quot; id=&quot;markdown-toc-单次运行&quot;&gt;单次运行&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#不正确的同步方式&quot; id=&quot;markdown-toc-不正确的同步方式&quot;&gt;不正确的同步方式&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#错误一双重检查锁定&quot; id=&quot;markdown-toc-错误一双重检查锁定&quot;&gt;错误一：双重检查锁定&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#错误二某个值的循环检查&quot; id=&quot;markdown-toc-错误二某个值的循环检查&quot;&gt;错误二：某个值的循环检查&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#错误三循环检查的变形&quot; id=&quot;markdown-toc-错误三循环检查的变形&quot;&gt;错误三：循环检查的变形&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;资料&quot;&gt;资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://golang.google.cn/ref/mem&quot;&gt;Go 内存模型原文地址&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/av79339158/&quot;&gt;本文的视频地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;简介introduction&quot;&gt;简介（Introduction）&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Go 内存模型&lt;/strong&gt;涉及到两个 Go协程 之间对同一个变量的读写。假如有一个变量，其中一个 Go协程(a) 写这个变量，另一个 Go协程(b) 读这个变量；Go 内存模型定义了&lt;strong&gt;什么情况下&lt;/strong&gt; Go协程(b) 能够确保读取到由 Go协程(a) 写入的值。&lt;/p&gt;

&lt;h2 id=&quot;建议advice&quot;&gt;建议（Advice）&lt;/h2&gt;

&lt;p&gt;多协程并发修改数据的程序必须保证各个步骤串行执行。&lt;/p&gt;

&lt;p&gt;为了串行执行各步，可以使用&lt;strong&gt;信道&lt;/strong&gt;或 &lt;a href=&quot;https://golang.google.cn/pkg/sync/&quot;&gt;sync&lt;/a&gt; 和 &lt;a href=&quot;https://golang.google.cn/pkg/sync/atomic/&quot;&gt;sync/atomic&lt;/a&gt; 两个包里的同步原语来保护被共享的数据。&lt;/p&gt;

&lt;p&gt;因为并发编程是一件很复杂的事情，请大家在学习本文的基础上再多加练习，不能仅依赖本文来掌握并发编程的知识。&lt;/p&gt;

&lt;h2 id=&quot;发生在之前happens-before&quot;&gt;发生在…之前（Happens Before）&lt;/h2&gt;

&lt;p&gt;在一个 Go协程 里，对同一个变量的读写必然是按照代码编写的顺序来执行的。对于多个变量的读写，如果重新排序不影响代码逻辑的正常执行，编译器和处理器可能会对多个变量的读写过程&lt;strong&gt;重新排序&lt;/strong&gt;；比如对于 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 1; b = 2&lt;/code&gt; 这两个语句，在同一个 Go协程 里先执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;a=1&lt;/code&gt; 还是先执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;b=2&lt;/code&gt; 其实是没有区别的。但是，因为重新排列执行顺序的情况的存在，会导致某个 Go协程 所观察到的执行顺序可能与另一个 Go协程 观察到的执行顺序不一样。还是拿 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 1; b = 2&lt;/code&gt; 举例，如果在某个协程里依次执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 1; b = 2&lt;/code&gt;，由于&lt;strong&gt;重新排序&lt;/strong&gt;的存在可能另一个 Go协程 观察到的事实是 &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; 的值先被更新，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 的值被后更新。&lt;/p&gt;

&lt;p&gt;为了表征读写需求，我们可以定义“发生在…之前”，用来表示 Go 语言中某一小段内存命令的执行顺序。如果事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;e1&lt;/code&gt; 发生在事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;e2&lt;/code&gt; 之前，此时我们就认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;e2&lt;/code&gt; 发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;e1&lt;/code&gt; 之后。如果事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;e1&lt;/code&gt; 既不发生在事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;e2&lt;/code&gt; 之前，也不发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;e2&lt;/code&gt; 之后，此时我们就认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;e1&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;e2&lt;/code&gt; 同时发生（并发）。&lt;/p&gt;

&lt;p&gt;在一个 Go协程 内部，谁发生在谁之前的顺序就是代码显式定义的顺序。比如：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;肯定是 &lt;code class=&quot;highlighter-rouge&quot;&gt;a := 1&lt;/code&gt; 先执行，&lt;code class=&quot;highlighter-rouge&quot;&gt;fmt.Println(a)&lt;/code&gt; 后执行。&lt;/p&gt;

&lt;p&gt;当 Go协程 不仅仅局限在一个的时候，存在下面两个规则：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则一&lt;/strong&gt;：如果存在一个变量 v，如果下面的两个条件都满足，则读操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; &lt;strong&gt;允许观察到&lt;/strong&gt;（可能观察到，也可能观察不到）写操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 写入的值：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; &lt;strong&gt;不在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 之前发生；&lt;/li&gt;
  &lt;li&gt;不存在其他的 &lt;code class=&quot;highlighter-rouge&quot;&gt;w’&lt;/code&gt; 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 之后发生，也不存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;w’&lt;/code&gt; 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 之前发生。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;规则二&lt;/strong&gt;：为了保证读操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 读取到的是写操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 写入的值，需要确保 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 是唯一允许被 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 观察到的写操作。如果下面的两个条件都满足，则 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 保证能够观察到 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 写入的值：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 之前；&lt;/li&gt;
  &lt;li&gt;其他对共享变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt; 的写操作要么发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 之前，要么发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 之后。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;规则二的条件比规则一的条件更为严格，它要求没有其他的写操作和 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 并发地发生。&lt;/p&gt;

&lt;p&gt;在一个 Go协程 里是不存在并发的，因此规则一和规则二是等效的：读操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 可以观察到最近一次写操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 写入的值。但是，当多个协程访问一个共享变量的时候，就必须&lt;strong&gt;使用同步事件来构建&lt;/strong&gt;“发生在…之前”的条件，从而保证读操作观察到的一定是想要的写操作。&lt;/p&gt;

&lt;p&gt;在内存模型中，变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt; 的零值初始化操作等同于一个写操作。&lt;/p&gt;

&lt;p&gt;如果变量的值大于&lt;strong&gt;单机器字&lt;/strong&gt;（CPU 从内存单次读取的字节数），那么 CPU 在读和写这个变量的时候是以一种不可预知顺序的多次执行&lt;strong&gt;单机器字&lt;/strong&gt;的操作，这也是  &lt;a href=&quot;https://golang.google.cn/pkg/sync/atomic/&quot;&gt;sync/atomic&lt;/a&gt;  包存在的价值。&lt;/p&gt;

&lt;h2 id=&quot;同步化synchronization&quot;&gt;同步化（Synchronization）&lt;/h2&gt;

&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;

&lt;p&gt;程序的初始化是在一个单独的 Go协程 中进行的，但是这个协程可以创建其他的 Go协程 并且二者并发执行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果一个包 &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; 导入了包 &lt;code class=&quot;highlighter-rouge&quot;&gt;q&lt;/code&gt;， 那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;q&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 函数的执行&lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;的所有 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 函数的执行&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;main.main&lt;/code&gt; 的执行&lt;strong&gt;发生在&lt;/strong&gt;所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 函数执行完成&lt;strong&gt;之后&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;go协程的创建&quot;&gt;Go协程的创建&lt;/h3&gt;

&lt;p&gt;在 Go 语言中通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;go&lt;/code&gt; 语句创建新的 Go协程 发生在这个 Go协程 的执行&lt;strong&gt;之前&lt;/strong&gt;。比如下面的例子：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello&lt;/code&gt; 会在调用后的某个时间点打印 “hello, world” ，这个时间点可能在 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello&lt;/code&gt; 函数返回之前，也可能在 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello&lt;/code&gt; 函数返回之后。&lt;/p&gt;

&lt;h3 id=&quot;go协程的销毁&quot;&gt;Go协程的销毁&lt;/h3&gt;

&lt;p&gt;Go协程的退出无法确保&lt;strong&gt;发生在&lt;/strong&gt;程序的某个事件&lt;strong&gt;之前&lt;/strong&gt;。比如下面的例子：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 的赋值语句没有任何的同步事件，因此无法保证被其他任意的 Go 协程观察到这个赋值事件的存在。事实上，一些编译器可能会在编译阶段删除上面代码中的整个 &lt;code class=&quot;highlighter-rouge&quot;&gt;go&lt;/code&gt; 语句。&lt;/p&gt;

&lt;p&gt;如果某个 Go协程 里发生的事件必然要被另一个 Go协程 观察到，需要使用同步机制进行保证，比如使用&lt;strong&gt;锁&lt;/strong&gt;或者&lt;strong&gt;信道&lt;/strong&gt;（channel）通信来构建一个相对的事件发生顺序。&lt;/p&gt;

&lt;h3 id=&quot;信道通信&quot;&gt;信道通信&lt;/h3&gt;

&lt;p&gt;信道通信是 Go协程 间事件同步的主要方式。在某个特定的信道上&lt;strong&gt;发送&lt;/strong&gt;一个数据，则对应地可以在这个信道上&lt;strong&gt;接收&lt;/strong&gt;一个数据，一般情况下是在不同的 Go协程 间发送与接收。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则一&lt;/strong&gt;：在某个信道上发送数据的事件&lt;strong&gt;发生在&lt;/strong&gt;相应的接收事件&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;看下面的代码：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这段代码保证了 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello, world&lt;/code&gt; 的打印。因为信道的写入事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;c &amp;lt;- 0&lt;/code&gt; &lt;strong&gt;发生在&lt;/strong&gt;读取事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;-c&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;-c&lt;/code&gt; &lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;print(a)&lt;/code&gt;&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则二&lt;/strong&gt;：信道的关闭事件&lt;strong&gt;发生在&lt;/strong&gt;从信道接收到零值（由信道关闭触发）&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在前面的例子中，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;close(c)&lt;/code&gt; 来替代 &lt;code class=&quot;highlighter-rouge&quot;&gt;c &amp;lt;- 0&lt;/code&gt; 语句来保证同样的效果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则三&lt;/strong&gt;：对于没有缓存的信道，数据的接收事件&lt;strong&gt;发生在&lt;/strong&gt;数据发送完成&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;比如下面的代码（类似上面给出的代码，但是使用了没有缓存的信道，且发送和接收的语句交换了一下）：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这段代码依然可以保证可以打印 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello, world&lt;/code&gt;。因为信道的写入事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;c &amp;lt;- 0&lt;/code&gt; &lt;strong&gt;发生在&lt;/strong&gt;读取事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;-c&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;-c&lt;/code&gt; &lt;strong&gt;发生在&lt;/strong&gt;写入事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;c &amp;lt;- 0&lt;/code&gt; 完成&lt;strong&gt;之前&lt;/strong&gt;，同时写入事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;c &amp;lt;- 0&lt;/code&gt; 的完成&lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;上面的代码，如果信道是带缓存的（比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;c = make(chan int, 1)&lt;/code&gt;），程序将不能保证会打印出 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello, world&lt;/code&gt;，它可能会打印出空字符串，也可能崩溃退出，或者表现出一些其他的症状。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则四&lt;/strong&gt;：对于容量为 C 的信道，接收第 k 个元素的事件&lt;strong&gt;发生在&lt;/strong&gt;第 k+C 个元素的发送&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;规则四是规则三在&lt;strong&gt;带缓存的信道&lt;/strong&gt;上的推广。它使得带缓存的信道可以模拟出&lt;strong&gt;计数信号量&lt;/strong&gt;：信道中元素的个数&lt;strong&gt;表示&lt;/strong&gt;活跃数，信道的容量&lt;strong&gt;表示&lt;/strong&gt;最大的可并发数；发送一个元素&lt;strong&gt;意味着&lt;/strong&gt;获取一个信号量，接收一个元素&lt;strong&gt;意味着&lt;/strong&gt;释放这个信号量。这是一种常见的限制并发的用法。&lt;/p&gt;

&lt;p&gt;下面的代码给工作列表中的每个入口都开启一个 Go协程，但是通过配合一个固定长度的信道保证了同时最多有 3 个运行的工作（最多 3 个并发）。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;work&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;锁&quot;&gt;锁&lt;/h3&gt;

&lt;p&gt;包 &lt;code class=&quot;highlighter-rouge&quot;&gt;sync&lt;/code&gt; 实现了两类锁数据类型，分别是 &lt;code class=&quot;highlighter-rouge&quot;&gt;sync.Mutex&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;sync.RWMutex&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则一&lt;/strong&gt;：对于类型为  &lt;code class=&quot;highlighter-rouge&quot;&gt;sync.Mutex&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;sync.RWMutex&lt;/code&gt; 的变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;l&lt;/code&gt;，如果存在 n 和 m 且满足 &lt;code class=&quot;highlighter-rouge&quot;&gt;n &amp;lt; m&lt;/code&gt;，则 &lt;code class=&quot;highlighter-rouge&quot;&gt;l.Unlock()&lt;/code&gt; 的第 n 次调用返回发生在&lt;code class=&quot;highlighter-rouge&quot;&gt;l.Lock()&lt;/code&gt;的第 m 次调用返回&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;比如下面的代码：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这段代码保证能够打印 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello, world&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;l.Unlock()&lt;/code&gt;的第 1 次调用返回（在函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt; 内部）&lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;l.Lock()&lt;/code&gt; 的第 2 次调用返回&lt;strong&gt;之前&lt;/strong&gt;，后者&lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则二&lt;/strong&gt;：存在类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;sync.RWMutex&lt;/code&gt; 的变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;l&lt;/code&gt;，如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;l.RLock&lt;/code&gt; 的调用返回&lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;l.Unlock&lt;/code&gt; 的第 n 次调用返回&lt;strong&gt;之后&lt;/strong&gt;，那么其对应的 &lt;code class=&quot;highlighter-rouge&quot;&gt;l.RUnlock&lt;/code&gt; &lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;l.Lock&lt;/code&gt; 的第 n+1 次调用返回&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;单次运行&quot;&gt;单次运行&lt;/h3&gt;

&lt;p&gt;包 &lt;code class=&quot;highlighter-rouge&quot;&gt;sync&lt;/code&gt; 还提供了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Once&lt;/code&gt; 类型用来保证多协程的初始化的安全。多个 Go协程 可以并发执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;once.Do(f)&lt;/code&gt; 来执行函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;， 且只会有一个 Go协程 会运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;f()&lt;/code&gt;，其他的 Go 协程会阻塞到那&lt;strong&gt;单次执行的&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;f()&lt;/code&gt; 的返回。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则一&lt;/strong&gt;：函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;f()&lt;/code&gt; 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;once.Do(f)&lt;/code&gt; 的单次调用返回&lt;strong&gt;发生在&lt;/strong&gt;其他所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;once.Do(f)&lt;/code&gt; 调用返回&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;比如下面的代码：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;once&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Once&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;once&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;twoprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码中 &lt;code class=&quot;highlighter-rouge&quot;&gt;twoprint&lt;/code&gt; 函数只会调用一次 &lt;code class=&quot;highlighter-rouge&quot;&gt;setup&lt;/code&gt; 函数。函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;setup&lt;/code&gt; 函数的执行返回&lt;strong&gt;发生在&lt;/strong&gt;所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt; 调用&lt;strong&gt;之前&lt;/strong&gt;，同时会打印出两次 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello, world&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;不正确的同步方式&quot;&gt;不正确的同步方式&lt;/h3&gt;

&lt;p&gt;对某个变量的读操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 一定概率可以观察到对同一个变量的并发写操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;，但是即使这件事情发生了，也并不意味着&lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; &lt;strong&gt;之后&lt;/strong&gt;的其他读操作可以观察到&lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;的其他写操作。&lt;/p&gt;

&lt;p&gt;比如下面的代码：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码里函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;g&lt;/code&gt; 可能会先打印 2（b的值），然后打印 0（a的值）；可能大家会认为既然 b 的值已经被赋值为 2 了，那么 a 的值肯定被赋值为 1 了，但事实是两个事件的先后在这里是没有办法确定的。&lt;/p&gt;

&lt;p&gt;上面的事实可以证明下面的几个常见的错误。&lt;/p&gt;

&lt;h4 id=&quot;错误一双重检查锁定&quot;&gt;错误一：双重检查锁定&lt;/h4&gt;

&lt;p&gt;双重检查锁定是一种尝试避免同步开销的尝试。比如下面的例子，&lt;code class=&quot;highlighter-rouge&quot;&gt;twoprint&lt;/code&gt; 函数可能会被&lt;strong&gt;错误地&lt;/strong&gt;编写为：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;once&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;twoprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;doprint&lt;/code&gt; 函数中，观察到对 &lt;code class=&quot;highlighter-rouge&quot;&gt;done&lt;/code&gt; 的写操作并不意味着能够观察到对 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 的写操作。应该注意，上面的写法依然有可能打印出空字符串而不是“hello, world”字符串。&lt;/p&gt;

&lt;h4 id=&quot;错误二某个值的循环检查&quot;&gt;错误二：某个值的循环检查&lt;/h4&gt;

&lt;p&gt;另一个常见的错误用法是对某个值的循环检查，比如下面的代码：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;和上一个例子类似，&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;函数中观察到对 &lt;code class=&quot;highlighter-rouge&quot;&gt;done&lt;/code&gt; 的写操作并不意味着可以观察到对 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 的写操作，因此上面的代码依然可能会打印出空字符串。更为恐怖的，由于两个 Go协程 之间缺少同步事件，&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数甚至可能永远无法观察到对 &lt;code class=&quot;highlighter-rouge&quot;&gt;done&lt;/code&gt; 变量的写操作，导致 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 中的 for 循环永远执行下去。&lt;/p&gt;

&lt;h4 id=&quot;错误三循环检查的变形&quot;&gt;错误三：循环检查的变形&lt;/h4&gt;

&lt;p&gt;错误二存在一个变形，如下面的代码所示：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码即使 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数观察到 &lt;code class=&quot;highlighter-rouge&quot;&gt;g != nil&lt;/code&gt;并且退出了它的 for 循环，依然没有办法保证它可以观察到被初始化的 &lt;code class=&quot;highlighter-rouge&quot;&gt;g.msg&lt;/code&gt; 值。&lt;/p&gt;

&lt;p&gt;避免上面几个错误用法的方式是一样的：显式使用同步语句。&lt;/p&gt;

</description>
        <pubDate>Sat, 14 Dec 2019 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2019/12/14/go-mem-model.html</link>
        <guid isPermaLink="true">https://jingwei.link/2019/12/14/go-mem-model.html</guid>
        
        <category>golang</category>
        
        <category>基础</category>
        
        <category>实用</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>《原汁原味 Go 语言学习》(12) effective go 错误抛出与捕获、恢复</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#资料&quot; id=&quot;markdown-toc-资料&quot;&gt;资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#错误errors&quot; id=&quot;markdown-toc-错误errors&quot;&gt;错误（Errors）&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#panicpanic&quot; id=&quot;markdown-toc-panicpanic&quot;&gt;Panic（Panic）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#恢复recover&quot; id=&quot;markdown-toc-恢复recover&quot;&gt;恢复（Recover）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;资料&quot;&gt;资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://golang.google.cn/doc/effective_go.html&quot;&gt;effective go&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/av77541066&quot;&gt;本文的视频地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;错误errors&quot;&gt;错误（Errors）&lt;/h1&gt;

&lt;p&gt;原则上，第三方库在报错时能给调用者返回有指示含义的错误信息。像之前提到的 Go 的&lt;strong&gt;多返回值&lt;/strong&gt;特性让&lt;strong&gt;同时返回普通返回值和详尽的错误描述&lt;/strong&gt;变得很简单。通过这个特性来提供详细的错误信息是一种很好的代码风格。比如，系统库函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;os.Open&lt;/code&gt; 在发生错误的时候不仅返回一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt; 的指针，同时返回一个错误变量来描述出问题的原因。&lt;/p&gt;

&lt;p&gt;为了方便，错误有一个专门的类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt;，它是一个内建的接口。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;包的创建者可以为自定义类型实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt; 接口，为调用者提供一些错误的上下文从而便于排查错误。就像刚刚提到的，系统库函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;os.Open&lt;/code&gt; 除了返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;*os.File&lt;/code&gt; 类型的值外，还返回了一个错误值；如果文件打开成功，错误值是 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;，如果文件打开失败，会返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;os.PathError&lt;/code&gt; 错误：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// PathError records an error and the operation and&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// file path that caused it.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PathError&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// &quot;open&quot;, &quot;unlink&quot;, etc.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Path&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// The associated file.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// Returned by the system call.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PathError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面 &lt;code class=&quot;highlighter-rouge&quot;&gt;PathError&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Error&lt;/code&gt; 方法会产生下面类似的字符串提示：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;open /etc/passwx: no such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的错误信息里面&lt;strong&gt;包含了&lt;/strong&gt;出问题的①文件名、②操作以及③触发的操作系统错误，这个信息对找出问题是很有帮助的，即使函数被层层调用报出这个错误也很容易定位问题。相比较而言，这种示意的输出比 “找不到相关的文件或目录” 这种提示要有用的多。&lt;/p&gt;

&lt;p&gt;大多数情况下，错误字符串最好能输出他们的源信息，比如什么操作导致的什么错误，比如哪个包的什么错误，等等。以包 &lt;code class=&quot;highlighter-rouge&quot;&gt;image&lt;/code&gt; 为例，由未知格式导致的编码错误的字符串提示统一都是：“图片：未知的格式”。&lt;/p&gt;

&lt;p&gt;如果调用者关注详细的错误类型，那就可以用 &lt;strong&gt;类型 switch&lt;/strong&gt; 或者&lt;strong&gt;类型断言&lt;/strong&gt;来查找特定的错误并抽取它的详细信息。对于下面代码中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;PathErrors&lt;/code&gt;，为了从操作失败中恢复，它可能包含了一个内部的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Err&lt;/code&gt; 字段：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PathError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ENOSPC&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// 没有空间了，删除一些临时文件获取空间，然后重试&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;deleteTempFiles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// Recover some space.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第二个 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 语句是一个类型断言，如果断言失败了，&lt;code class=&quot;highlighter-rouge&quot;&gt;ok&lt;/code&gt; 值就是 false，此时 &lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt; 的值是 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;；如果断言成功，&lt;code class=&quot;highlighter-rouge&quot;&gt;ok&lt;/code&gt; 值是 true，此时意味着错误值的类型是 &lt;code class=&quot;highlighter-rouge&quot;&gt;*os.PathError&lt;/code&gt;，接着 &lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt; 就可以做进一步的检查并执行对应的操作了。&lt;/p&gt;

&lt;h2 id=&quot;panicpanic&quot;&gt;Panic（Panic）&lt;/h2&gt;

&lt;p&gt;报错最常见的方式是给调用者返回一个额外的 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt; 类型的值；典型的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Read&lt;/code&gt; 方法是一个很好的例子，它返回字节数的同时还返回一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt;类型的值。那么我们思考，如果错误没有被覆盖怎么办呢？这时候程序可能不能继续运行下去。&lt;/p&gt;

&lt;p&gt;Go 的内建函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 会创建一个运行时错误，并且终止程序的执行。这个函数可以接收一个任意类型的参数（通常是一个字符串），程序终止后会把这个参数打印出来。除此之外，还可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 来表明代码里存在一些不应该发生的逻辑，比如存在一个无限循环逻辑，如下面的代码所示：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// A toy implementation of cube root using Newton's method.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CubeRoot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;// Arbitrary initial value&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1e6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;prevz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;veryClose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// A million iterations has not converged; something is wrong.&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;CubeRoot(%g) did not converge&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码只是一个示例，真实的&lt;strong&gt;库&lt;/strong&gt;代码逻辑中应该避免使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 函数。假如问题可以被预知并被处理掉，比起终止整个程序更好的方式是让代码继续运行下去。在少有的一些情况下，使用 panic 能简化编码逻辑，比如在计数例子的初始化过程中可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt;：如果包不能成功启用，意味着可能发生了什么重大的错误，此时可以抛出 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt;。下面代码示例中如果没有设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;USER&lt;/code&gt; 系统变量，就抛出 &lt;code class=&quot;highlighter-rouge&quot;&gt;Panic&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Getenv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USER&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;no value for $USER&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;恢复recover&quot;&gt;恢复（Recover）&lt;/h2&gt;

&lt;p&gt;在发生运行时错误时，比如越界访问切片，或者类型断言失败，&lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 会被调用，此时当前函数的执行立即停止，并且开始展开 Goroutine 的堆栈，在这个过程中被推迟执行（defer）的函数会被依次执行。如果堆栈一直展开到达了 goroutine 的栈顶，代码就退出了。我们可以通过内建的 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 函数来重新获取 goroutine 的控制权并且恢复其正常的执行。&lt;/p&gt;

&lt;p&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 可以停止堆栈的展开，并获取得到传递给 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 的参数。因为在堆栈展开的过程中只有被 defer 的函数会被执行，因此 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 只有放在被 defer 的函数中才有意义。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 的一个应用场景是：当服务器中有失败的 Goroutine 的时候，直接关闭对应的 Goroutine，避免影响其他正在执行的 Goroutine。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;workChan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Work&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;work&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workChan&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safelyDo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;work&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safelyDo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;work&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Work&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;recover&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;work failed:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;work&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面的例子中，如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;do(work)&lt;/code&gt; 运行时出错（&lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt;），结果会被记录下来，并且 Goroutine 会干净利落地退出而不会影响到其他的 Goroutine。对于上面的情况，在&lt;strong&gt;推迟&lt;/strong&gt;函数中直接调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 就可以完全处理相应的状况，不需要做其他的事情。&lt;/p&gt;

&lt;p&gt;如果不是在被 defer 的函数中调用，&lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 总是返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt; 值；因此，被推迟执行的函数逻辑里可以调用使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 的第三方库。比如，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;safelyDo&lt;/code&gt; 的推迟函数里可以在调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 之前调用一个日志函数，日志相关的逻辑不会受 panicking 的状态的影响。&lt;/p&gt;

&lt;p&gt;使用上面例子中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;recovery&lt;/code&gt; 的用法，&lt;code class=&quot;highlighter-rouge&quot;&gt;do&lt;/code&gt; 函数（包含它调用的任何东西）可以通过调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 干净利落地处理任何坏状况。我们可以把这种模式应用在复杂的软件中从而简化错误处理。让我们看一下理想状态下的 &lt;code class=&quot;highlighter-rouge&quot;&gt;regexp&lt;/code&gt; 包，可以通过调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 并传入一个本地的错误类型来解析错误信息（这里指的是&lt;strong&gt;准确地解析&lt;/strong&gt;，继续看下面的解释）。下面的代码定义了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Error&lt;/code&gt; 类型， &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Compile&lt;/code&gt; 方法：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Error is the type of a parse error; it satisfies the error interface.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// error is a method of *Regexp that reports parsing errors by&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// panicking with an Error.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regexp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Regexp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// Compile returns a parsed representation of the regular expression.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regexp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Regexp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;regexp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Regexp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// doParse will panic if there is a parse error.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;recover&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;regexp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// Clear return value.&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Will re-panic if not a parse error.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;regexp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doParse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;doParse&lt;/code&gt; 报错，恢复的代码块会把返回值 &lt;code class=&quot;highlighter-rouge&quot;&gt;regexp&lt;/code&gt; 设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;——被 defer 的函数可以修改命名的返回值。然后在 &lt;code class=&quot;highlighter-rouge&quot;&gt;err&lt;/code&gt; 的赋值语句断言 &lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt; 是不是一个本地类型的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Error&lt;/code&gt;。如果它不是本地的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Error&lt;/code&gt;，类型断言会失败，从而造成一个新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt;，因此堆栈会就像没有被中断过一样继续展开。这种检查意味着如果有未预知的事情发生，比如索引溢出，即使我们使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 处理了解析错误的报错，代码依然会报错。&lt;/p&gt;

&lt;p&gt;有了上面错误处理的逻辑以后，配合定义的 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt; 方法，同时简化了报错的方式，不用再想着手动处理堆栈的事情（因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt; 方法绑定到了类型上，而且与内建的 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt; 类型有相同的名字，因此使用起来也很优雅自然，）。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;'*' illegal at start of expression&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;虽然 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic/recover&lt;/code&gt; 的这种模式很有用，但是应该只限定在一个包里使用。&lt;code class=&quot;highlighter-rouge&quot;&gt;Parse&lt;/code&gt; 没有把 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 暴露给自己的调用者，而是把内部的 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 转换成了 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt; 值返回，这是一个可供参考的最佳实践。&lt;/p&gt;

&lt;p&gt;需要注意，如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 后又发生了 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt;，这种写法会改变 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 的值。不过幸运的是，在崩溃报告中原始报错和新的报错都会打印出来，因此导致错误的根源依然是可见的。如果想展示引发 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 的原始值，可以写一点代码来过滤未知问题然后用原生的错误重新发起 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt;，这一点大家可以自己来实践一下。&lt;/p&gt;

&lt;p&gt;【effective go 完】&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Nov 2019 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2019/11/30/effectivego-errors.html</link>
        <guid isPermaLink="true">https://jingwei.link/2019/11/30/effectivego-errors.html</guid>
        
        <category>golang</category>
        
        <category>基础</category>
        
        <category>实用</category>
        
        
        <category>golang</category>
        
      </item>
    
  </channel>
</rss>