<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>敬维</title>
    <description>一个喜欢涂涂画画的人，曾经的Rubist，一个CI/CD的践行者，一个探寻最佳实践的人。</description>
    <link>https://jingwei.link//</link>
    <atom:link href="https://jingwei.link/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 05 Apr 2020 20:20:05 +0800</pubDate>
    <lastBuildDate>Sun, 05 Apr 2020 20:20:05 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>职场人士应该学什么以及如何学习（编码领域）</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#写在前面&quot; id=&quot;markdown-toc-写在前面&quot;&gt;写在前面&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#知识的不同层级&quot; id=&quot;markdown-toc-知识的不同层级&quot;&gt;知识的不同层级&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#自己应该学习什么&quot; id=&quot;markdown-toc-自己应该学习什么&quot;&gt;自己应该学习什么&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#知识的分类应该怎么学&quot; id=&quot;markdown-toc-知识的分类应该怎么学&quot;&gt;知识的分类（应该怎么学）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;俗话说，“活到老学到老”。对程序员而言，尤其如此；或者说的严重一点，程序员唯有此一条路。然而，无论是职场新人还是职场老手，能够坚持学习的人却凤毛麟角。一方面是因为&lt;strong&gt;坚持学习&lt;/strong&gt;需要很强的毅力，而人有偷懒的劣根在；另一方面则是因为学习目标模糊，不知道该学什么，也不知道该怎么学。&lt;/p&gt;

&lt;p&gt;如果把坚持学习看做一个习惯，如何培养这个习惯本文不做讨论，大家可以先自行思考；本文只尝试分析知识的层级，从而便于我们认清&lt;strong&gt;自己应该学习什么以及应该怎么学习&lt;/strong&gt;。&lt;/p&gt;

&lt;h2 id=&quot;知识的不同层级&quot;&gt;知识的不同层级&lt;/h2&gt;

&lt;p&gt;假设任何领域的知识分为不同的层级。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
（↑实践）
&lt;span class=&quot;c&quot;&gt;############################################################&lt;/span&gt;
L3 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;domain knowlege&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;     | L3-1 | L3-2  |  |  L3-3 | L3-4 | 
&lt;span class=&quot;c&quot;&gt;#########################|##############|##|##############|#&lt;/span&gt;
L2 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;practice knowledge&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;  |    L2-1      |  |     L2-2     | 
&lt;span class=&quot;c&quot;&gt;############################################################&lt;/span&gt;
L1 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;general knowlege&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;###################################&lt;/span&gt;
L0（low-level knowledge&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;###########################&lt;/span&gt;
（↓理论）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;（某个领域的知识等级图）&lt;/p&gt;

&lt;p&gt;L0 代表&lt;strong&gt;底层基础层&lt;/strong&gt;，表示那些比较少涉及到的知识；L1 代表&lt;strong&gt;通用知识识层&lt;/strong&gt;，表示只要涉及当前领域的工作就需要掌握的基础知识；L2 代表实践层，这个层级的知识开始出现领域上的初步分化；L3 代表领域层，包含更为专业的领域知识。越往下面越偏向理论，越往上面越偏向实践。直白地理解，越往下越接近课堂里学习到的知识，越往上越接近工作中用到的知识。&lt;/p&gt;

&lt;p&gt;作为一名编码者，理想情况下需要从 L0 到 L3 逐一训练自己的能力。但是在精力限制以及时间限制的情况下，无法顾全所有，只能有选择性地进行学习。&lt;/p&gt;

&lt;h3 id=&quot;自己应该学习什么&quot;&gt;自己应该学习什么&lt;/h3&gt;

&lt;p&gt;在讨论知识的时候，庄子曾讲“吾生也有涯，而知也无涯”，那么多知识根本学习不完；这对于学习者来说算是&lt;strong&gt;一个坏消息&lt;/strong&gt;。但是并不意味着放弃学习是一件睿智的选择（其实放弃学习是很愚蠢的选择），因为还有一个好消息，解决工作上的实际问题并不需要所有的知识，有时候解决一个问题只需要掌握一小块知识就足够了；这对于学习者来说算是&lt;strong&gt;一个好消息&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;自己应该学习什么？如果目前工作中需要某个技能，但是自己不具备这个技能，投入时间精力学习吧！如果自己未来的工作中（工作转型）需要某个技能，但是自己目前不具备这个技能，也投入时间学习吧！&lt;/p&gt;

&lt;p&gt;如果自己不知道当前的工作需要哪个技能，也不知道自己未来的工作需要哪个技能，说明自己处于迷茫阶段，不妨尝试一些别的事情。对于非 IT 领域的同学，可以尝试学习一门编程语言；对于已经是 IT 领域的同学，可以尝试通读一下某个编程语言的手册文档；等等。&lt;/p&gt;

&lt;h3 id=&quot;知识的分类应该怎么学&quot;&gt;知识的分类（应该怎么学）&lt;/h3&gt;

&lt;p&gt;根据我的学习经历及工作经验，我发现基本上可以把知识分成下面几类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;死记硬背型的知识点（比如九九乘法口诀）&lt;/li&gt;
  &lt;li&gt;系统理论型的知识点（比如乘法竖列式）&lt;/li&gt;
  &lt;li&gt;一系列的知识点形成的领域栈只是（比如仅 python 技术栈包含了成百上千个知识点）&lt;/li&gt;
  &lt;li&gt;只有经历过才会有的知识（也就是一般所说的经验）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这四类里面，死记硬背型的知识点需要花费时间进行记忆，如果记忆力比较好短时间或许可以掌握；系统理论型的知识点主要凭借逻辑思维能力进行学习，如果理解能力好一点也可以短时间内掌握。前面的这两种知识点通过比较短的时间是可以掌握的，但是接下来的&lt;strong&gt;领域栈只是和经验上的知识都需要时间上的打磨&lt;/strong&gt;，尤其经验，没有时间上的积累几乎是不可能有成绩的。&lt;/p&gt;

&lt;p&gt;如果读者朋友已结束学生时代步入社会，或许已经可以意识到：很多聪明的小孩子自认为凭借着自己的聪明才智可以很容易地收获所有知识，从而不付出努力学习，这是一件多么愚蠢的行为。有的知识的学习本就是耗时耗精力的，是没有捷径掌握的。&lt;/p&gt;

&lt;p&gt;如果&lt;strong&gt;确认了自己应该学习的领域栈，不遗余力地学习这个领域栈的知识点，然后想尽一切办法实践这些知识点吧&lt;/strong&gt;！&lt;/p&gt;

</description>
        <pubDate>Sun, 05 Apr 2020 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2020/04/05/learning-methodology.html</link>
        <guid isPermaLink="true">https://jingwei.link/2020/04/05/learning-methodology.html</guid>
        
        <category>基础</category>
        
        <category>实用</category>
        
        
        <category>编程</category>
        
      </item>
    
      <item>
        <title>如何为 Go 语言源码仓库贡献代码</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#写在前面&quot; id=&quot;markdown-toc-写在前面&quot;&gt;写在前面&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#为-go-语言源码仓库贡献代码&quot; id=&quot;markdown-toc-为-go-语言源码仓库贡献代码&quot;&gt;为 Go 语言源码仓库贡献代码&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#我们往往忽略了官方材料的学习&quot; id=&quot;markdown-toc-我们往往忽略了官方材料的学习&quot;&gt;我们往往忽略了官方材料的学习&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#如何为-go-语言源码仓库贡献代码&quot; id=&quot;markdown-toc-如何为-go-语言源码仓库贡献代码&quot;&gt;如何为 Go 语言源码仓库贡献代码&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#小结&quot; id=&quot;markdown-toc-小结&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;二零一九年（2019）利用业余的时间做了一套&lt;a href=&quot;https://github.com/chalvern/books/tree/master/go/official_go_learning&quot;&gt;《原汁原味Go语言学习》&lt;/a&gt;的视频课程，主要涉及到 Go 官方的几个文档资料的学习。在翻译官方文档的过程中发现有一处错误（前前后后看了很多遍，每次看到都觉得不爽），调研后发现是 Go 源码仓库中的文档，于是心血来潮修正错误并提交了 commit，私心里还琢磨着如果代码被合并自己以后岂不就可以吹嘘是&lt;strong&gt;Go语言源码的贡献者&lt;/strong&gt;了？&lt;/p&gt;

&lt;p&gt;按照官方指引，春节放假前提交修正并得到管理员的正反馈，然后一直关注了好久但不见代码被合并，一度以为自己的这个提交被忽略了，不过最近看到已经被合并到了&lt;a href=&quot;https://github.com/golang/go/commit/34830beffa6396129bd9d9da58afb7a046775d49&quot;&gt;Go主分支&lt;/a&gt;。开心😸。&lt;/p&gt;

&lt;p&gt;其实整个提交过程还是比较流畅的，现在简单总结记录一下供自己以及他人参考。&lt;/p&gt;

&lt;h2 id=&quot;为-go-语言源码仓库贡献代码&quot;&gt;为 Go 语言源码仓库贡献代码&lt;/h2&gt;

&lt;h3 id=&quot;我们往往忽略了官方材料的学习&quot;&gt;我们往往忽略了官方材料的学习&lt;/h3&gt;

&lt;p&gt;由于每个人学习编程的方式不同，可能无法评估出编程的最佳学习方式；但是作为熟练程度的基准，语言的官方文档理应是其最佳的学习资料。以 Go 语言为例，可能市面上存在很多 Go 语言相关的书籍，但是任何一本书都无法让自己精通 Go 语言编程（如果有类似标榜的书籍，千万不要买）；从这个角度讲，书籍只能作为编程语言学习的指引者——激起学习者的学习热情，启发学习者的学习路径——其他的技术细节和技巧仍然需要学习者自己去探索体会。&lt;/p&gt;

&lt;p&gt;不过虽说编程语言的官方文档是最佳的学习资料，但是官方文档往往是枯燥无趣的，因此也难怪很多人都不喜欢读。可是，编程语言的学习与掌握本就是一个枯燥无趣的过程，又有什么办法……&lt;/p&gt;

&lt;h3 id=&quot;如何为-go-语言源码仓库贡献代码&quot;&gt;如何为 Go 语言源码仓库贡献代码&lt;/h3&gt;

&lt;p&gt;只需参考 《&lt;a href=&quot;https://golang.google.cn/doc/contribute.html&quot;&gt;Contribution Guide 官方文档&lt;/a&gt;》即可。&lt;/p&gt;

&lt;p&gt;大家可以看到整个文档都是英文资料，且在提交代码让别人审核的过程中也都是英文沟通交流，因此这里关键的点或许是把英文学好……&lt;/p&gt;

&lt;p&gt;从我个人的经验看，只要英文够好，确实发现了源码中不合理的地方，又觉得自己有好点子，都可以为 Go 语言贡献代码。为了破除大家对提交代码这件事情的神秘感，这里简单罗列一下&lt;a href=&quot;https://golang.google.cn/doc/contribute.html&quot;&gt;官方文档&lt;/a&gt;里介绍的几个点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先准备好账户并签署贡献者协议（Google账户、Gerrit账户）；&lt;/li&gt;
  &lt;li&gt;配置自己本地的环境（配置 git、配置 gerrit，后者是谷歌官方提供的一个小工具，可以保持自己的 commit 信息的规范）；&lt;/li&gt;
  &lt;li&gt;修改完代码后就可以使用 gerrit 提交了;&lt;/li&gt;
  &lt;li&gt;提交完成后到 https://go.googlesource.com/ 可以观察进度，甚至可能需要根据修改意见进行内容上的阐述、修改等；&lt;/li&gt;
  &lt;li&gt;等提交的内容被完全认同以后，剩下的就是耐心等着被合并到 Master 主分支了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;

&lt;p&gt;自己的代码被合并到主仓库，好像这份开心慢慢地也消散了。终于还是要踏踏实实地解决业务问题，如此自己的创造才是有价值的。&lt;/p&gt;

</description>
        <pubDate>Sun, 15 Mar 2020 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2020/03/15/contribute_golang_process.html</link>
        <guid isPermaLink="true">https://jingwei.link/2020/03/15/contribute_golang_process.html</guid>
        
        <category>golang</category>
        
        <category>最佳实践</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>更实用的 Go 开发的社区论坛——apollo 开源项目介绍</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#apollo-项目&quot; id=&quot;markdown-toc-apollo-项目&quot;&gt;apollo 项目&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#使用到的库或框架&quot; id=&quot;markdown-toc-使用到的库或框架&quot;&gt;使用到的库（或框架）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#安装运行&quot; id=&quot;markdown-toc-安装运行&quot;&gt;安装运行&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#环境要求&quot; id=&quot;markdown-toc-环境要求&quot;&gt;环境要求&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#详细步骤&quot; id=&quot;markdown-toc-详细步骤&quot;&gt;详细步骤&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#其他资料&quot; id=&quot;markdown-toc-其他资料&quot;&gt;其他资料&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;apollo-项目&quot;&gt;apollo 项目&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/chalvern/apollo&quot;&gt;apollo&lt;/a&gt; 项目的主体是一个 go 语言原生的 bbs 社区系统，主要为了弥补当前 go 语言原生社区系统的空白。在前后端分离盛行的今天，越来越多的技术细节被默认存在，无形中也就增加了初学者在这个技术栈的学习门槛。&lt;a href=&quot;https://github.com/chalvern/apollo&quot;&gt;apollo&lt;/a&gt; 项目专注在 go 技术栈，从命令行启动、配置读取，到数据库访问、html模板渲染，均直接采用了 go 对应的库；除了语言层面的学习，&lt;a href=&quot;https://github.com/chalvern/apollo&quot;&gt;apollo&lt;/a&gt; 项目还抽象了一些 web 设计中可能涉及的基本点，从而便于初学者未来了解设计更为宏大的项目。&lt;/p&gt;

&lt;p&gt;由于经验尚浅，再加上时间因素约束，项目中难免有一些不雅的设计，欢迎大家创建 issue 指出问题，并欢迎大家提交更为完善的代码。&lt;/p&gt;

&lt;p&gt;设计细节请查看 &lt;a href=&quot;https://github.com/chalvern/apollo/tree/master/wiki&quot;&gt;wiki&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;使用到的库或框架&quot;&gt;使用到的库（或框架）&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;web——&lt;a href=&quot;https://github.com/gin-gonic/gin&quot;&gt;gin&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;ORM——&lt;a href=&quot;https://github.com/jinzhu/gorm&quot;&gt;gorm&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;日志——&lt;a href=&quot;https://github.com/uber-go/zap&quot;&gt;uber/zap&lt;/a&gt;/&lt;a href=&quot;https://github.com/chalvern/sugar&quot;&gt;sugar&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;配置——&lt;a href=&quot;https://github.com/spf13/viper&quot;&gt;viper&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;其他可参考 &lt;a href=&quot;../go.mod&quot;&gt;go.mod&lt;/a&gt; 文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;安装运行&quot;&gt;安装运行&lt;/h1&gt;

&lt;p&gt;apollo 是一个功能轻完备的项目，目前它已具备注册、登陆、注销、发帖、编辑、回复等功能，可以在一些简单应用场景下使用。可以到 http://www.jianzhoubian.com) 预览，测试好像只能使用 http 协议而不能使用 https 协议访问=。=&lt;/p&gt;

&lt;h2 id=&quot;环境要求&quot;&gt;环境要求&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;安装 go（version &amp;gt;= 1.13）&lt;/li&gt;
  &lt;li&gt;安装 MySQL（apollo 使用了 5.7.28 进行的开发)&lt;/li&gt;
  &lt;li&gt;（可选）安装 make (Linux 和 MacOS 上默认应该都有)，如果没有安装，则需要手动运行一些命令&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;详细步骤&quot;&gt;详细步骤&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;下载本仓库的代码(后面的操作都是在项目目录下执行)；&lt;/li&gt;
  &lt;li&gt;根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;configs/config.yml.example&lt;/code&gt; 创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;configs/config.yml&lt;/code&gt; 文件；&lt;/li&gt;
  &lt;li&gt;根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;configs/config.yml&lt;/code&gt; 中数据库（database）的配置，在 MySQL 中创建用户及数据库。下面以 &lt;code class=&quot;highlighter-rouge&quot;&gt;apollo&lt;/code&gt; 为例&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 创建 apollo 数据库，默认字符集为 utf8mb4&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DATABASE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`apollo`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`utf8mb4`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- 创建用户名为 jingwei 密码为 20200101 的用户，并赋权 apollo 的所有权限给 jingwei&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;GRANT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ALL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PRIVILEGES&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;apollo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TO&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;jingwei&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&quot;%&quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IDENTIFIED&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;&quot;20200101&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;迁移数据表结构：&lt;/p&gt;

    &lt;p&gt;1.1 如果安装了 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 工具，直接运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;make migrate&lt;/code&gt; 即可完成数据表的迁移。&lt;/p&gt;

    &lt;p&gt;1.2 如果没有安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 工具，依次执行：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 下载依赖&lt;/span&gt;
go mod tidy
&lt;span class=&quot;c&quot;&gt;# 构建 apollo.exe 二进制执行文件&lt;/span&gt;
go build &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; apollo.exe main.go

&lt;span class=&quot;c&quot;&gt;# 执行迁移&lt;/span&gt;
./apollo.exe migrate
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;通过命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;./apollo.exe&lt;/code&gt; 运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;apollo&lt;/code&gt; 项目。&lt;/li&gt;
  &lt;li&gt;通过浏览器访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost:2020&lt;/code&gt; 即可看到对应的页面。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;其他资料&quot;&gt;其他资料&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/av86199253&quot;&gt;视频介绍&lt;/a&gt; 【原汁原味go语言学习】(14) 实践篇之 apollo 开源项目介绍&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 08 Feb 2020 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2020/02/08/appolo-go-web-blog.html</link>
        <guid isPermaLink="true">https://jingwei.link/2020/02/08/appolo-go-web-blog.html</guid>
        
        <category>golang</category>
        
        <category>实用</category>
        
        <category>最佳实践</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>为团队寻找后端开发工程师（招聘）</title>
        <description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;程序员是“活到老学到老”的践行者，无论是前端开发者还是后端开发者，都是如此。希望你也是这样的程序员。&lt;/p&gt;

&lt;p&gt;在加入当前的公司（&lt;strong&gt;上海·桂林路&lt;/strong&gt;）后，随着公司业务逐渐展开，发现团队里的事情也多起来了，因此开贴找一起共事一起学习的同事。&lt;/p&gt;

&lt;h2 id=&quot;后端开发工程师&quot;&gt;后端开发工程师&lt;/h2&gt;

&lt;p&gt;职位描述：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;参与完成项目的系统分析、设计，并负责业务功能与底层基础功能的功能设计、代码实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;希望你：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;有 2 年以上的后端开发经验；&lt;/li&gt;
  &lt;li&gt;熟练使用 Java/Go/Python 中的一种或多种编程语言；&lt;/li&gt;
  &lt;li&gt;了解并能熟练使用常见的数据库（Mysql、ElasticSearch、MongoDB、Redis 等）；&lt;/li&gt;
  &lt;li&gt;掌握计算机基本理论知识，包括基础网络、存储、算法等；&lt;/li&gt;
  &lt;li&gt;如果自我感觉良好，可以不受上面条款的限制。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;欢迎邮件（zhjw43@163.com）骚扰。&lt;/p&gt;
</description>
        <pubDate>Fri, 03 Jan 2020 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2020/01/03/you-can-be-my-coworker.html</link>
        <guid isPermaLink="true">https://jingwei.link/2020/01/03/you-can-be-my-coworker.html</guid>
        
        <category>管理</category>
        
        <category>实用</category>
        
        
        <category>管理</category>
        
      </item>
    
      <item>
        <title>《原汁原味 Go 语言学习》(13) Go 内存模型</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#资料&quot; id=&quot;markdown-toc-资料&quot;&gt;资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#简介introduction&quot; id=&quot;markdown-toc-简介introduction&quot;&gt;简介（Introduction）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#建议advice&quot; id=&quot;markdown-toc-建议advice&quot;&gt;建议（Advice）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#发生在之前happens-before&quot; id=&quot;markdown-toc-发生在之前happens-before&quot;&gt;发生在…之前（Happens Before）&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#同步化synchronization&quot; id=&quot;markdown-toc-同步化synchronization&quot;&gt;同步化（Synchronization）&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#初始化&quot; id=&quot;markdown-toc-初始化&quot;&gt;初始化&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#go协程的创建&quot; id=&quot;markdown-toc-go协程的创建&quot;&gt;Go协程的创建&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#go协程的销毁&quot; id=&quot;markdown-toc-go协程的销毁&quot;&gt;Go协程的销毁&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#信道通信&quot; id=&quot;markdown-toc-信道通信&quot;&gt;信道通信&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#锁&quot; id=&quot;markdown-toc-锁&quot;&gt;锁&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#单次运行&quot; id=&quot;markdown-toc-单次运行&quot;&gt;单次运行&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#不正确的同步方式&quot; id=&quot;markdown-toc-不正确的同步方式&quot;&gt;不正确的同步方式&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#错误一双重检查锁定&quot; id=&quot;markdown-toc-错误一双重检查锁定&quot;&gt;错误一：双重检查锁定&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#错误二某个值的循环检查&quot; id=&quot;markdown-toc-错误二某个值的循环检查&quot;&gt;错误二：某个值的循环检查&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#错误三循环检查的变形&quot; id=&quot;markdown-toc-错误三循环检查的变形&quot;&gt;错误三：循环检查的变形&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;资料&quot;&gt;资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://golang.google.cn/ref/mem&quot;&gt;Go 内存模型原文地址&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/av79339158/&quot;&gt;本文的视频地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;简介introduction&quot;&gt;简介（Introduction）&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Go 内存模型&lt;/strong&gt;涉及到两个 Go协程 之间对同一个变量的读写。假如有一个变量，其中一个 Go协程(a) 写这个变量，另一个 Go协程(b) 读这个变量；Go 内存模型定义了&lt;strong&gt;什么情况下&lt;/strong&gt; Go协程(b) 能够确保读取到由 Go协程(a) 写入的值。&lt;/p&gt;

&lt;h2 id=&quot;建议advice&quot;&gt;建议（Advice）&lt;/h2&gt;

&lt;p&gt;多协程并发修改数据的程序必须保证各个步骤串行执行。&lt;/p&gt;

&lt;p&gt;为了串行执行各步，可以使用&lt;strong&gt;信道&lt;/strong&gt;或 &lt;a href=&quot;https://golang.google.cn/pkg/sync/&quot;&gt;sync&lt;/a&gt; 和 &lt;a href=&quot;https://golang.google.cn/pkg/sync/atomic/&quot;&gt;sync/atomic&lt;/a&gt; 两个包里的同步原语来保护被共享的数据。&lt;/p&gt;

&lt;p&gt;因为并发编程是一件很复杂的事情，请大家在学习本文的基础上再多加练习，不能仅依赖本文来掌握并发编程的知识。&lt;/p&gt;

&lt;h2 id=&quot;发生在之前happens-before&quot;&gt;发生在…之前（Happens Before）&lt;/h2&gt;

&lt;p&gt;在一个 Go协程 里，对同一个变量的读写必然是按照代码编写的顺序来执行的。对于多个变量的读写，如果重新排序不影响代码逻辑的正常执行，编译器和处理器可能会对多个变量的读写过程&lt;strong&gt;重新排序&lt;/strong&gt;；比如对于 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 1; b = 2&lt;/code&gt; 这两个语句，在同一个 Go协程 里先执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;a=1&lt;/code&gt; 还是先执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;b=2&lt;/code&gt; 其实是没有区别的。但是，因为重新排列执行顺序的情况的存在，会导致某个 Go协程 所观察到的执行顺序可能与另一个 Go协程 观察到的执行顺序不一样。还是拿 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 1; b = 2&lt;/code&gt; 举例，如果在某个协程里依次执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;a = 1; b = 2&lt;/code&gt;，由于&lt;strong&gt;重新排序&lt;/strong&gt;的存在可能另一个 Go协程 观察到的事实是 &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; 的值先被更新，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 的值被后更新。&lt;/p&gt;

&lt;p&gt;为了表征读写需求，我们可以定义“发生在…之前”，用来表示 Go 语言中某一小段内存命令的执行顺序。如果事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;e1&lt;/code&gt; 发生在事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;e2&lt;/code&gt; 之前，此时我们就认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;e2&lt;/code&gt; 发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;e1&lt;/code&gt; 之后。如果事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;e1&lt;/code&gt; 既不发生在事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;e2&lt;/code&gt; 之前，也不发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;e2&lt;/code&gt; 之后，此时我们就认为 &lt;code class=&quot;highlighter-rouge&quot;&gt;e1&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;e2&lt;/code&gt; 同时发生（并发）。&lt;/p&gt;

&lt;p&gt;在一个 Go协程 内部，谁发生在谁之前的顺序就是代码显式定义的顺序。比如：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;肯定是 &lt;code class=&quot;highlighter-rouge&quot;&gt;a := 1&lt;/code&gt; 先执行，&lt;code class=&quot;highlighter-rouge&quot;&gt;fmt.Println(a)&lt;/code&gt; 后执行。&lt;/p&gt;

&lt;p&gt;当 Go协程 不仅仅局限在一个的时候，存在下面两个规则：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则一&lt;/strong&gt;：如果存在一个变量 v，如果下面的两个条件都满足，则读操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; &lt;strong&gt;允许观察到&lt;/strong&gt;（可能观察到，也可能观察不到）写操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 写入的值：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; &lt;strong&gt;不在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 之前发生；&lt;/li&gt;
  &lt;li&gt;不存在其他的 &lt;code class=&quot;highlighter-rouge&quot;&gt;w’&lt;/code&gt; 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 之后发生，也不存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;w’&lt;/code&gt; 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 之前发生。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;规则二&lt;/strong&gt;：为了保证读操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 读取到的是写操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 写入的值，需要确保 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 是唯一允许被 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 观察到的写操作。如果下面的两个条件都满足，则 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 保证能够观察到 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 写入的值：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 之前；&lt;/li&gt;
  &lt;li&gt;其他对共享变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt; 的写操作要么发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 之前，要么发生在 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 之后。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;规则二的条件比规则一的条件更为严格，它要求没有其他的写操作和 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 并发地发生。&lt;/p&gt;

&lt;p&gt;在一个 Go协程 里是不存在并发的，因此规则一和规则二是等效的：读操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 可以观察到最近一次写操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; 写入的值。但是，当多个协程访问一个共享变量的时候，就必须&lt;strong&gt;使用同步事件来构建&lt;/strong&gt;“发生在…之前”的条件，从而保证读操作观察到的一定是想要的写操作。&lt;/p&gt;

&lt;p&gt;在内存模型中，变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;v&lt;/code&gt; 的零值初始化操作等同于一个写操作。&lt;/p&gt;

&lt;p&gt;如果变量的值大于&lt;strong&gt;单机器字&lt;/strong&gt;（CPU 从内存单次读取的字节数），那么 CPU 在读和写这个变量的时候是以一种不可预知顺序的多次执行&lt;strong&gt;单机器字&lt;/strong&gt;的操作，这也是  &lt;a href=&quot;https://golang.google.cn/pkg/sync/atomic/&quot;&gt;sync/atomic&lt;/a&gt;  包存在的价值。&lt;/p&gt;

&lt;h2 id=&quot;同步化synchronization&quot;&gt;同步化（Synchronization）&lt;/h2&gt;

&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;

&lt;p&gt;程序的初始化是在一个单独的 Go协程 中进行的，但是这个协程可以创建其他的 Go协程 并且二者并发执行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果一个包 &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt; 导入了包 &lt;code class=&quot;highlighter-rouge&quot;&gt;q&lt;/code&gt;， 那么 &lt;code class=&quot;highlighter-rouge&quot;&gt;q&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 函数的执行&lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;p&lt;/code&gt;的所有 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 函数的执行&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;main.main&lt;/code&gt; 的执行&lt;strong&gt;发生在&lt;/strong&gt;所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 函数执行完成&lt;strong&gt;之后&lt;/strong&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;go协程的创建&quot;&gt;Go协程的创建&lt;/h3&gt;

&lt;p&gt;在 Go 语言中通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;go&lt;/code&gt; 语句创建新的 Go协程 发生在这个 Go协程 的执行&lt;strong&gt;之前&lt;/strong&gt;。比如下面的例子：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello&lt;/code&gt; 会在调用后的某个时间点打印 “hello, world” ，这个时间点可能在 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello&lt;/code&gt; 函数返回之前，也可能在 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello&lt;/code&gt; 函数返回之后。&lt;/p&gt;

&lt;h3 id=&quot;go协程的销毁&quot;&gt;Go协程的销毁&lt;/h3&gt;

&lt;p&gt;Go协程的退出无法确保&lt;strong&gt;发生在&lt;/strong&gt;程序的某个事件&lt;strong&gt;之前&lt;/strong&gt;。比如下面的例子：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 的赋值语句没有任何的同步事件，因此无法保证被其他任意的 Go 协程观察到这个赋值事件的存在。事实上，一些编译器可能会在编译阶段删除上面代码中的整个 &lt;code class=&quot;highlighter-rouge&quot;&gt;go&lt;/code&gt; 语句。&lt;/p&gt;

&lt;p&gt;如果某个 Go协程 里发生的事件必然要被另一个 Go协程 观察到，需要使用同步机制进行保证，比如使用&lt;strong&gt;锁&lt;/strong&gt;或者&lt;strong&gt;信道&lt;/strong&gt;（channel）通信来构建一个相对的事件发生顺序。&lt;/p&gt;

&lt;h3 id=&quot;信道通信&quot;&gt;信道通信&lt;/h3&gt;

&lt;p&gt;信道通信是 Go协程 间事件同步的主要方式。在某个特定的信道上&lt;strong&gt;发送&lt;/strong&gt;一个数据，则对应地可以在这个信道上&lt;strong&gt;接收&lt;/strong&gt;一个数据，一般情况下是在不同的 Go协程 间发送与接收。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则一&lt;/strong&gt;：在某个信道上发送数据的事件&lt;strong&gt;发生在&lt;/strong&gt;相应的接收事件&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;看下面的代码：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这段代码保证了 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello, world&lt;/code&gt; 的打印。因为信道的写入事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;c &amp;lt;- 0&lt;/code&gt; &lt;strong&gt;发生在&lt;/strong&gt;读取事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;-c&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;-c&lt;/code&gt; &lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;print(a)&lt;/code&gt;&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则二&lt;/strong&gt;：信道的关闭事件&lt;strong&gt;发生在&lt;/strong&gt;从信道接收到零值（由信道关闭触发）&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在前面的例子中，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;close(c)&lt;/code&gt; 来替代 &lt;code class=&quot;highlighter-rouge&quot;&gt;c &amp;lt;- 0&lt;/code&gt; 语句来保证同样的效果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则三&lt;/strong&gt;：对于没有缓存的信道，数据的接收事件&lt;strong&gt;发生在&lt;/strong&gt;数据发送完成&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;比如下面的代码（类似上面给出的代码，但是使用了没有缓存的信道，且发送和接收的语句交换了一下）：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这段代码依然可以保证可以打印 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello, world&lt;/code&gt;。因为信道的写入事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;c &amp;lt;- 0&lt;/code&gt; &lt;strong&gt;发生在&lt;/strong&gt;读取事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;-c&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;，而 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;-c&lt;/code&gt; &lt;strong&gt;发生在&lt;/strong&gt;写入事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;c &amp;lt;- 0&lt;/code&gt; 完成&lt;strong&gt;之前&lt;/strong&gt;，同时写入事件 &lt;code class=&quot;highlighter-rouge&quot;&gt;c &amp;lt;- 0&lt;/code&gt; 的完成&lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;上面的代码，如果信道是带缓存的（比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;c = make(chan int, 1)&lt;/code&gt;），程序将不能保证会打印出 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello, world&lt;/code&gt;，它可能会打印出空字符串，也可能崩溃退出，或者表现出一些其他的症状。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则四&lt;/strong&gt;：对于容量为 C 的信道，接收第 k 个元素的事件&lt;strong&gt;发生在&lt;/strong&gt;第 k+C 个元素的发送&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;规则四是规则三在&lt;strong&gt;带缓存的信道&lt;/strong&gt;上的推广。它使得带缓存的信道可以模拟出&lt;strong&gt;计数信号量&lt;/strong&gt;：信道中元素的个数&lt;strong&gt;表示&lt;/strong&gt;活跃数，信道的容量&lt;strong&gt;表示&lt;/strong&gt;最大的可并发数；发送一个元素&lt;strong&gt;意味着&lt;/strong&gt;获取一个信号量，接收一个元素&lt;strong&gt;意味着&lt;/strong&gt;释放这个信号量。这是一种常见的限制并发的用法。&lt;/p&gt;

&lt;p&gt;下面的代码给工作列表中的每个入口都开启一个 Go协程，但是通过配合一个固定长度的信道保证了同时最多有 3 个运行的工作（最多 3 个并发）。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;work&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;select&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;锁&quot;&gt;锁&lt;/h3&gt;

&lt;p&gt;包 &lt;code class=&quot;highlighter-rouge&quot;&gt;sync&lt;/code&gt; 实现了两类锁数据类型，分别是 &lt;code class=&quot;highlighter-rouge&quot;&gt;sync.Mutex&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;sync.RWMutex&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则一&lt;/strong&gt;：对于类型为  &lt;code class=&quot;highlighter-rouge&quot;&gt;sync.Mutex&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;sync.RWMutex&lt;/code&gt; 的变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;l&lt;/code&gt;，如果存在 n 和 m 且满足 &lt;code class=&quot;highlighter-rouge&quot;&gt;n &amp;lt; m&lt;/code&gt;，则 &lt;code class=&quot;highlighter-rouge&quot;&gt;l.Unlock()&lt;/code&gt; 的第 n 次调用返回发生在&lt;code class=&quot;highlighter-rouge&quot;&gt;l.Lock()&lt;/code&gt;的第 m 次调用返回&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;比如下面的代码：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mutex&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Unlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这段代码保证能够打印 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello, world&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;l.Unlock()&lt;/code&gt;的第 1 次调用返回（在函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt; 内部）&lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;l.Lock()&lt;/code&gt; 的第 2 次调用返回&lt;strong&gt;之前&lt;/strong&gt;，后者&lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则二&lt;/strong&gt;：存在类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;sync.RWMutex&lt;/code&gt; 的变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;l&lt;/code&gt;，如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;l.RLock&lt;/code&gt; 的调用返回&lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;l.Unlock&lt;/code&gt; 的第 n 次调用返回&lt;strong&gt;之后&lt;/strong&gt;，那么其对应的 &lt;code class=&quot;highlighter-rouge&quot;&gt;l.RUnlock&lt;/code&gt; &lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;l.Lock&lt;/code&gt; 的第 n+1 次调用返回&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;单次运行&quot;&gt;单次运行&lt;/h3&gt;

&lt;p&gt;包 &lt;code class=&quot;highlighter-rouge&quot;&gt;sync&lt;/code&gt; 还提供了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Once&lt;/code&gt; 类型用来保证多协程的初始化的安全。多个 Go协程 可以并发执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;once.Do(f)&lt;/code&gt; 来执行函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;， 且只会有一个 Go协程 会运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;f()&lt;/code&gt;，其他的 Go 协程会阻塞到那&lt;strong&gt;单次执行的&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;f()&lt;/code&gt; 的返回。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;规则一&lt;/strong&gt;：函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;f()&lt;/code&gt; 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;once.Do(f)&lt;/code&gt; 的单次调用返回&lt;strong&gt;发生在&lt;/strong&gt;其他所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;once.Do(f)&lt;/code&gt; 调用返回&lt;strong&gt;之前&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;比如下面的代码：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;once&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sync&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Once&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;once&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;twoprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码中 &lt;code class=&quot;highlighter-rouge&quot;&gt;twoprint&lt;/code&gt; 函数只会调用一次 &lt;code class=&quot;highlighter-rouge&quot;&gt;setup&lt;/code&gt; 函数。函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;setup&lt;/code&gt; 函数的执行返回&lt;strong&gt;发生在&lt;/strong&gt;所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;print&lt;/code&gt; 调用&lt;strong&gt;之前&lt;/strong&gt;，同时会打印出两次 &lt;code class=&quot;highlighter-rouge&quot;&gt;hello, world&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;不正确的同步方式&quot;&gt;不正确的同步方式&lt;/h3&gt;

&lt;p&gt;对某个变量的读操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; 一定概率可以观察到对同一个变量的并发写操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt;，但是即使这件事情发生了，也并不意味着&lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;r&lt;/code&gt; &lt;strong&gt;之后&lt;/strong&gt;的其他读操作可以观察到&lt;strong&gt;发生在&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;w&lt;/code&gt; &lt;strong&gt;之前&lt;/strong&gt;的其他写操作。&lt;/p&gt;

&lt;p&gt;比如下面的代码：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码里函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;g&lt;/code&gt; 可能会先打印 2（b的值），然后打印 0（a的值）；可能大家会认为既然 b 的值已经被赋值为 2 了，那么 a 的值肯定被赋值为 1 了，但事实是两个事件的先后在这里是没有办法确定的。&lt;/p&gt;

&lt;p&gt;上面的事实可以证明下面的几个常见的错误。&lt;/p&gt;

&lt;h4 id=&quot;错误一双重检查锁定&quot;&gt;错误一：双重检查锁定&lt;/h4&gt;

&lt;p&gt;双重检查锁定是一种尝试避免同步开销的尝试。比如下面的例子，&lt;code class=&quot;highlighter-rouge&quot;&gt;twoprint&lt;/code&gt; 函数可能会被&lt;strong&gt;错误地&lt;/strong&gt;编写为：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;once&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;twoprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;doprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;doprint&lt;/code&gt; 函数中，观察到对 &lt;code class=&quot;highlighter-rouge&quot;&gt;done&lt;/code&gt; 的写操作并不意味着能够观察到对 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 的写操作。应该注意，上面的写法依然有可能打印出空字符串而不是“hello, world”字符串。&lt;/p&gt;

&lt;h4 id=&quot;错误二某个值的循环检查&quot;&gt;错误二：某个值的循环检查&lt;/h4&gt;

&lt;p&gt;另一个常见的错误用法是对某个值的循环检查，比如下面的代码：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;和上一个例子类似，&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt;函数中观察到对 &lt;code class=&quot;highlighter-rouge&quot;&gt;done&lt;/code&gt; 的写操作并不意味着可以观察到对 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; 的写操作，因此上面的代码依然可能会打印出空字符串。更为恐怖的，由于两个 Go协程 之间缺少同步事件，&lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数甚至可能永远无法观察到对 &lt;code class=&quot;highlighter-rouge&quot;&gt;done&lt;/code&gt; 变量的写操作，导致 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 中的 for 循环永远执行下去。&lt;/p&gt;

&lt;h4 id=&quot;错误三循环检查的变形&quot;&gt;错误三：循环检查的变形&lt;/h4&gt;

&lt;p&gt;错误二存在一个变形，如下面的代码所示：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;hello, world&quot;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;setup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码即使 &lt;code class=&quot;highlighter-rouge&quot;&gt;main&lt;/code&gt; 函数观察到 &lt;code class=&quot;highlighter-rouge&quot;&gt;g != nil&lt;/code&gt;并且退出了它的 for 循环，依然没有办法保证它可以观察到被初始化的 &lt;code class=&quot;highlighter-rouge&quot;&gt;g.msg&lt;/code&gt; 值。&lt;/p&gt;

&lt;p&gt;避免上面几个错误用法的方式是一样的：显式使用同步语句。&lt;/p&gt;

</description>
        <pubDate>Sat, 14 Dec 2019 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2019/12/14/go-mem-model.html</link>
        <guid isPermaLink="true">https://jingwei.link/2019/12/14/go-mem-model.html</guid>
        
        <category>golang</category>
        
        <category>基础</category>
        
        <category>实用</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>《原汁原味 Go 语言学习》(12) effective go 错误抛出与捕获、恢复</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#资料&quot; id=&quot;markdown-toc-资料&quot;&gt;资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#错误errors&quot; id=&quot;markdown-toc-错误errors&quot;&gt;错误（Errors）&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#panicpanic&quot; id=&quot;markdown-toc-panicpanic&quot;&gt;Panic（Panic）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#恢复recover&quot; id=&quot;markdown-toc-恢复recover&quot;&gt;恢复（Recover）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;资料&quot;&gt;资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://golang.google.cn/doc/effective_go.html&quot;&gt;effective go&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/av77541066&quot;&gt;本文的视频地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;错误errors&quot;&gt;错误（Errors）&lt;/h1&gt;

&lt;p&gt;原则上，第三方库在报错时能给调用者返回有指示含义的错误信息。像之前提到的 Go 的&lt;strong&gt;多返回值&lt;/strong&gt;特性让&lt;strong&gt;同时返回普通返回值和详尽的错误描述&lt;/strong&gt;变得很简单。通过这个特性来提供详细的错误信息是一种很好的代码风格。比如，系统库函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;os.Open&lt;/code&gt; 在发生错误的时候不仅返回一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt; 的指针，同时返回一个错误变量来描述出问题的原因。&lt;/p&gt;

&lt;p&gt;为了方便，错误有一个专门的类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt;，它是一个内建的接口。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;包的创建者可以为自定义类型实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt; 接口，为调用者提供一些错误的上下文从而便于排查错误。就像刚刚提到的，系统库函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;os.Open&lt;/code&gt; 除了返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;*os.File&lt;/code&gt; 类型的值外，还返回了一个错误值；如果文件打开成功，错误值是 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;，如果文件打开失败，会返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;os.PathError&lt;/code&gt; 错误：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// PathError records an error and the operation and&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// file path that caused it.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PathError&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// &quot;open&quot;, &quot;unlink&quot;, etc.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Path&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// The associated file.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// Returned by the system call.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PathError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Op&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Path&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面 &lt;code class=&quot;highlighter-rouge&quot;&gt;PathError&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Error&lt;/code&gt; 方法会产生下面类似的字符串提示：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;open /etc/passwx: no such file or directory
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的错误信息里面&lt;strong&gt;包含了&lt;/strong&gt;出问题的①文件名、②操作以及③触发的操作系统错误，这个信息对找出问题是很有帮助的，即使函数被层层调用报出这个错误也很容易定位问题。相比较而言，这种示意的输出比 “找不到相关的文件或目录” 这种提示要有用的多。&lt;/p&gt;

&lt;p&gt;大多数情况下，错误字符串最好能输出他们的源信息，比如什么操作导致的什么错误，比如哪个包的什么错误，等等。以包 &lt;code class=&quot;highlighter-rouge&quot;&gt;image&lt;/code&gt; 为例，由未知格式导致的编码错误的字符串提示统一都是：“图片：未知的格式”。&lt;/p&gt;

&lt;p&gt;如果调用者关注详细的错误类型，那就可以用 &lt;strong&gt;类型 switch&lt;/strong&gt; 或者&lt;strong&gt;类型断言&lt;/strong&gt;来查找特定的错误并抽取它的详细信息。对于下面代码中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;PathErrors&lt;/code&gt;，为了从操作失败中恢复，它可能包含了一个内部的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Err&lt;/code&gt; 字段：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;filename&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PathError&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;syscall&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ENOSPC&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// 没有空间了，删除一些临时文件获取空间，然后重试&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;deleteTempFiles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// Recover some space.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;第二个 &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; 语句是一个类型断言，如果断言失败了，&lt;code class=&quot;highlighter-rouge&quot;&gt;ok&lt;/code&gt; 值就是 false，此时 &lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt; 的值是 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;；如果断言成功，&lt;code class=&quot;highlighter-rouge&quot;&gt;ok&lt;/code&gt; 值是 true，此时意味着错误值的类型是 &lt;code class=&quot;highlighter-rouge&quot;&gt;*os.PathError&lt;/code&gt;，接着 &lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt; 就可以做进一步的检查并执行对应的操作了。&lt;/p&gt;

&lt;h2 id=&quot;panicpanic&quot;&gt;Panic（Panic）&lt;/h2&gt;

&lt;p&gt;报错最常见的方式是给调用者返回一个额外的 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt; 类型的值；典型的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Read&lt;/code&gt; 方法是一个很好的例子，它返回字节数的同时还返回一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt;类型的值。那么我们思考，如果错误没有被覆盖怎么办呢？这时候程序可能不能继续运行下去。&lt;/p&gt;

&lt;p&gt;Go 的内建函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 会创建一个运行时错误，并且终止程序的执行。这个函数可以接收一个任意类型的参数（通常是一个字符串），程序终止后会把这个参数打印出来。除此之外，还可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 来表明代码里存在一些不应该发生的逻辑，比如存在一个无限循环逻辑，如下面的代码所示：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// A toy implementation of cube root using Newton's method.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CubeRoot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;float64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;// Arbitrary initial value&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1e6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;prevz&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;veryClose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevz&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// A million iterations has not converged; something is wrong.&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;CubeRoot(%g) did not converge&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码只是一个示例，真实的&lt;strong&gt;库&lt;/strong&gt;代码逻辑中应该避免使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 函数。假如问题可以被预知并被处理掉，比起终止整个程序更好的方式是让代码继续运行下去。在少有的一些情况下，使用 panic 能简化编码逻辑，比如在计数例子的初始化过程中可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt;：如果包不能成功启用，意味着可能发生了什么重大的错误，此时可以抛出 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt;。下面代码示例中如果没有设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;USER&lt;/code&gt; 系统变量，就抛出 &lt;code class=&quot;highlighter-rouge&quot;&gt;Panic&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Getenv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;USER&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;no value for $USER&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;恢复recover&quot;&gt;恢复（Recover）&lt;/h2&gt;

&lt;p&gt;在发生运行时错误时，比如越界访问切片，或者类型断言失败，&lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 会被调用，此时当前函数的执行立即停止，并且开始展开 Goroutine 的堆栈，在这个过程中被推迟执行（defer）的函数会被依次执行。如果堆栈一直展开到达了 goroutine 的栈顶，代码就退出了。我们可以通过内建的 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 函数来重新获取 goroutine 的控制权并且恢复其正常的执行。&lt;/p&gt;

&lt;p&gt;调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 可以停止堆栈的展开，并获取得到传递给 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 的参数。因为在堆栈展开的过程中只有被 defer 的函数会被执行，因此 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 只有放在被 defer 的函数中才有意义。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 的一个应用场景是：当服务器中有失败的 Goroutine 的时候，直接关闭对应的 Goroutine，避免影响其他正在执行的 Goroutine。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;workChan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Work&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;work&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;workChan&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safelyDo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;work&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;safelyDo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;work&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Work&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;recover&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;work failed:&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;do&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;work&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上面的例子中，如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;do(work)&lt;/code&gt; 运行时出错（&lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt;），结果会被记录下来，并且 Goroutine 会干净利落地退出而不会影响到其他的 Goroutine。对于上面的情况，在&lt;strong&gt;推迟&lt;/strong&gt;函数中直接调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 就可以完全处理相应的状况，不需要做其他的事情。&lt;/p&gt;

&lt;p&gt;如果不是在被 defer 的函数中调用，&lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 总是返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt; 值；因此，被推迟执行的函数逻辑里可以调用使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 的第三方库。比如，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;safelyDo&lt;/code&gt; 的推迟函数里可以在调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 之前调用一个日志函数，日志相关的逻辑不会受 panicking 的状态的影响。&lt;/p&gt;

&lt;p&gt;使用上面例子中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;recovery&lt;/code&gt; 的用法，&lt;code class=&quot;highlighter-rouge&quot;&gt;do&lt;/code&gt; 函数（包含它调用的任何东西）可以通过调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 干净利落地处理任何坏状况。我们可以把这种模式应用在复杂的软件中从而简化错误处理。让我们看一下理想状态下的 &lt;code class=&quot;highlighter-rouge&quot;&gt;regexp&lt;/code&gt; 包，可以通过调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 并传入一个本地的错误类型来解析错误信息（这里指的是&lt;strong&gt;准确地解析&lt;/strong&gt;，继续看下面的解释）。下面的代码定义了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Error&lt;/code&gt; 类型， &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Compile&lt;/code&gt; 方法：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Error is the type of a parse error; it satisfies the error interface.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// error is a method of *Regexp that reports parsing errors by&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// panicking with an Error.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regexp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Regexp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;panic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// Compile returns a parsed representation of the regular expression.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Compile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;regexp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Regexp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;regexp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Regexp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// doParse will panic if there is a parse error.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;recover&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;regexp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// Clear return value.&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Will re-panic if not a parse error.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;regexp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;doParse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;doParse&lt;/code&gt; 报错，恢复的代码块会把返回值 &lt;code class=&quot;highlighter-rouge&quot;&gt;regexp&lt;/code&gt; 设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;——被 defer 的函数可以修改命名的返回值。然后在 &lt;code class=&quot;highlighter-rouge&quot;&gt;err&lt;/code&gt; 的赋值语句断言 &lt;code class=&quot;highlighter-rouge&quot;&gt;e&lt;/code&gt; 是不是一个本地类型的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Error&lt;/code&gt;。如果它不是本地的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Error&lt;/code&gt;，类型断言会失败，从而造成一个新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt;，因此堆栈会就像没有被中断过一样继续展开。这种检查意味着如果有未预知的事情发生，比如索引溢出，即使我们使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 处理了解析错误的报错，代码依然会报错。&lt;/p&gt;

&lt;p&gt;有了上面错误处理的逻辑以后，配合定义的 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt; 方法，同时简化了报错的方式，不用再想着手动处理堆栈的事情（因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt; 方法绑定到了类型上，而且与内建的 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt; 类型有相同的名字，因此使用起来也很优雅自然，）。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;'*' illegal at start of expression&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;虽然 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic/recover&lt;/code&gt; 的这种模式很有用，但是应该只限定在一个包里使用。&lt;code class=&quot;highlighter-rouge&quot;&gt;Parse&lt;/code&gt; 没有把 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 暴露给自己的调用者，而是把内部的 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 转换成了 &lt;code class=&quot;highlighter-rouge&quot;&gt;error&lt;/code&gt; 值返回，这是一个可供参考的最佳实践。&lt;/p&gt;

&lt;p&gt;需要注意，如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;recover&lt;/code&gt; 后又发生了 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt;，这种写法会改变 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 的值。不过幸运的是，在崩溃报告中原始报错和新的报错都会打印出来，因此导致错误的根源依然是可见的。如果想展示引发 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt; 的原始值，可以写一点代码来过滤未知问题然后用原生的错误重新发起 &lt;code class=&quot;highlighter-rouge&quot;&gt;panic&lt;/code&gt;，这一点大家可以自己来实践一下。&lt;/p&gt;

&lt;p&gt;【effective go 完】&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Nov 2019 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2019/11/30/effectivego-errors.html</link>
        <guid isPermaLink="true">https://jingwei.link/2019/11/30/effectivego-errors.html</guid>
        
        <category>golang</category>
        
        <category>基础</category>
        
        <category>实用</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>《原汁原味 Go 语言学习》(11) effective go 并发编程</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#资料&quot; id=&quot;markdown-toc-资料&quot;&gt;资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#并发concurrency&quot; id=&quot;markdown-toc-并发concurrency&quot;&gt;并发（Concurrency）&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#以通信的方式共享变量share-by-communicating&quot; id=&quot;markdown-toc-以通信的方式共享变量share-by-communicating&quot;&gt;以通信的方式共享变量（Share by communicating）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#go-协程goroutines&quot; id=&quot;markdown-toc-go-协程goroutines&quot;&gt;Go 协程（Goroutines）&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#信道channels&quot; id=&quot;markdown-toc-信道channels&quot;&gt;信道（Channels）&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#信道中的信道channels-of-channels&quot; id=&quot;markdown-toc-信道中的信道channels-of-channels&quot;&gt;信道中的信道（Channels of channels）&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#并行parallelization&quot; id=&quot;markdown-toc-并行parallelization&quot;&gt;并行（Parallelization）&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#缓存漏斗a-leaky-buffer&quot; id=&quot;markdown-toc-缓存漏斗a-leaky-buffer&quot;&gt;缓存漏斗（A leaky buffer）&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;资料&quot;&gt;资料&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://golang.google.cn/doc/effective_go.html&quot;&gt;effective go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av76858443&quot;&gt;本文的视频地址&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;并发concurrency&quot;&gt;并发（Concurrency）&lt;/h1&gt;

&lt;h2 id=&quot;以通信的方式共享变量share-by-communicating&quot;&gt;以通信的方式共享变量（Share by communicating）&lt;/h2&gt;

&lt;p&gt;并发编程是个很大的话题，本小节只考虑 Go 相关的特性。&lt;/p&gt;

&lt;p&gt;在很多环境中，并发编程都不容易；为了确保正确访问共享变量，里面需要注意很多的实现细节。Go 鼓励一种不同的编程方式：避免直接在不同的线程间共享变量，而是通过信道来共享变量的值。在任何时间点只有一个协程有权访问变量的值；在设计上就杜绝了数据竞争的情况。为了鼓励这种共享变量的方式，它还有一句口号：&lt;strong&gt;不要通过共享内存进行通信，相反，通过通信来共享内存&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;当然，这种“以通信的方式共享变量”的方式也不是万能的。比如，引用计数的最佳实现方式依然是给一个整数添加一个互斥锁的方式。但是作为一种高级别方式，使用信道来控制共享变量的访问能够让开发者更容易写出简明正确的代码。&lt;/p&gt;

&lt;p&gt;那么该怎么思考这个模型呢？假设我们有一个独立线程的程序，它只运行在一个 CPU 核上，这种情况下显然没有必要进行任何同步。现在思考有另一个类似的实例，它也是独立线程的，而且也只允许在一个 CPU 核上，这个实例也不需要任何的同步。然后，我们让这两个线程进行通信；如果通信方式是同步的，那么这两个独立的线程之间就不需要其他的同步了。Unix 里的 Pipline（管道） 模式就属于类似的模型。虽然 Go 解决并发的解决方案源自 Hoare 的CSP（通信序列过程）模型，但是它也可以看做是 Unix 管道的带类型安全限定的通用版本。&lt;/p&gt;

&lt;h2 id=&quot;go-协程goroutines&quot;&gt;Go 协程（Goroutines）&lt;/h2&gt;

&lt;p&gt;之所以叫 &lt;strong&gt;goroutines（Go协程）&lt;/strong&gt; ，是因为已有的术语——线程、协程、进程等——和要传达的含义并不完全匹配。每个 Go协程 都包含同一个简单的模型：首先它是一个函数，并且它和其他的 Go协程 在同一个地址空间同时运行。Go协程 是轻量级的，消耗的资源几乎只包含分配堆栈空间花费的那一点资源；同时因为它的堆栈初始化时很小，且总是依照实际需要来增加（或释放）堆存储，它也是很廉价的（意味着我们可以很容易地创建成千上万的 goroutines）。&lt;/p&gt;

&lt;p&gt;Go协程 多路复用多个操作系统线程。也就是说，假设有 m 个 Go协程 n 个系统线程，这 m 个 Go协程 里的任意一个都可能在 n 个系统线程的任意一个上面执行。因此如果某个 Go协程 因为 I/O 调用阻塞了，其他的协程可以继续运行。Go 运行时在这里的设计隐藏了很多线程创建和管理的复杂度。&lt;/p&gt;

&lt;p&gt;Go协程的创建也很简单，只需要在函数/方法的前面加一个关键词 &lt;code class=&quot;highlighter-rouge&quot;&gt;go&lt;/code&gt; 就可以让这个函数/方法在一个新的 goroutine 中运行。当函数/方法调用结束时，goroutine 会静默退出。（这里有点类似于 Unix Shell 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt; 符号）&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// run list.Sort concurrently; don't wait for it.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;函数声明语法可以配合 goroutine 的声明使用。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Announce&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Duration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;message&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// Note the parentheses - must call the function.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 Go 中，&lt;strong&gt;函数即闭包：在实现上，如果某个变量被函数引用了，那么它就会与函数一起存活&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;因为上面的例子里函数都没有标识自己什么时候退出，我们也就无法知道它们是不是把任务完成了，因此没有太大的实践意义。为此需要引入信道。&lt;/p&gt;

&lt;h3 id=&quot;信道channels&quot;&gt;信道（Channels）&lt;/h3&gt;

&lt;p&gt;和映射一样，信道通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 来分配内存，返回的结果等效于是对底层数据结构的引用。在使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;make&lt;/code&gt; 时如果传入了一个可选的整数，会创建带缓存的信道；如果不传默认就是 0，此时创建的是一个没有缓存的信道或者称为同步信道。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ci&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;            &lt;span class=&quot;c&quot;&gt;// unbuffered channel of integers&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;         &lt;span class=&quot;c&quot;&gt;// unbuffered channel of integers&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// buffered channel of pointers to Files&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果两个 Go协程 通过没有缓存的信道进行通信，这个没有缓存的信道同时可以做一些同步的事情，从而保证两个 Go协程 运行在已知的状态。&lt;/p&gt;

&lt;p&gt;有很多应用信道的惯例，我们可以从下面的例子开始。前面小节我们在后台启用了一个排序例程，但是无法知道这个例程什么时候执行完毕；信道可以允许我们启动一个 Goroutine 并显式地等待相应的例程结束。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// Allocate a channel.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Start the sort in a goroutine; when it completes, signal on the channel.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// Send a signal; value does not matter.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;doSomethingForAWhile&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;   &lt;span class=&quot;c&quot;&gt;// Wait for sort to finish; discard sent value.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在接收到数据前接收器（比如上例中 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;-c&lt;/code&gt; 语句）会一直阻塞在那里。对于一个没有缓存的信道来说，在接收器&lt;strong&gt;接收完成&lt;/strong&gt;之前发送器也会一直阻塞在那里（属于内存模型的一部分）。如果信道有空闲的缓存空间，发送器只在值拷贝到缓存区之前是阻塞的；如果缓冲区满了，发送器会一直等待，直到有接收器消费缓存中的值。&lt;/p&gt;

&lt;p&gt;带缓存的信道可以作为信号量来使用，比如可以用它来控制吞吐量。在下面的例子里，过来的请求被传到 &lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt;，然后 &lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt; 会首先给一个信道塞一个值（相当于占坑），接着处理这个请求，最后再从信道中消费一个值释放“信号量”从而给下一个消费者腾出资源。这里信道的缓冲区容量限定了 &lt;code class=&quot;highlighter-rouge&quot;&gt;process&lt;/code&gt; 的并发数量。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MaxOutstanding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// Wait for active queue to drain.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// May take a long time.&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sem&lt;/span&gt;       &lt;span class=&quot;c&quot;&gt;// Done; enable next request to run.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Serve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// Don't wait for handle to finish.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;一旦 &lt;code class=&quot;highlighter-rouge&quot;&gt;MaxOutstanding&lt;/code&gt; 个处理器运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;process&lt;/code&gt;，任何其他的 Go协程 尝试发送数据到信道的行为都会被阻塞，直到某个 &lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt; 结束并消费了信道中的数据。&lt;/p&gt;

&lt;p&gt;虽然很优雅，不过上面的设计是有问题的：虽然控制了最多只能有 &lt;code class=&quot;highlighter-rouge&quot;&gt;MaxOutstanding&lt;/code&gt; 个 Go协程 同时执行，但是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Serve&lt;/code&gt; 会给每个进来的请求都创建一个新的 Go协程。也就是说，只要请求进来的够快，程序会无限消耗资源。我们可以通过修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;Serve&lt;/code&gt; 函数限定 goroutine 的创建数量来解决这个缺陷。下面是一个显而易见的解决方案（不过隐藏了一个 bug 需要修复）：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Serve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Buggy; see explanation below.&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sem&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面代码的 bug 发生在 Go 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt; 循环：&lt;strong&gt;循环变量在每次迭代时会被复用&lt;/strong&gt;，因此 &lt;code class=&quot;highlighter-rouge&quot;&gt;req&lt;/code&gt; 变量在各个 Go协程 之间是共享的。由于上面的例子里我们不希望 &lt;code class=&quot;highlighter-rouge&quot;&gt;req&lt;/code&gt; 被共享，因此需要给每个 Go协程 传一个唯一的 &lt;code class=&quot;highlighter-rouge&quot;&gt;req&lt;/code&gt;。下面的代码给每个 Go协程 的闭包传递了 &lt;code class=&quot;highlighter-rouge&quot;&gt;req&lt;/code&gt; 作为其参数，因为函数参数是传值的（大家可以回顾函数那一节的内容），因此避免了上面的 bug：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Serve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sem&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以把上面的代码和前面带 &lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt; 函数的代码比较，看看闭包是如何声明并运行的。其实上面的 bug 还有一个解决方案，就是每次循环时创建一个同名的临时变量，如下面的代码所示：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Serve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Create new instance of req for the goroutine.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sem&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;或许 &lt;code class=&quot;highlighter-rouge&quot;&gt;req := req&lt;/code&gt; 的写法很怪异，但是在 Go 中这是合法的惯用写法。通过这种方法我们可以得到一个同名的新变量，通过刻意覆盖本地的循环变量的方式给每个 Go协程 提供了唯一的变量（而不是共享的 &lt;code class=&quot;highlighter-rouge&quot;&gt;req&lt;/code&gt; 变量）。&lt;/p&gt;

&lt;p&gt;接下来让我们回到写服务器常见的资源管理的问题。上面讨论的例子里，另一种资源管理的好方法是初始化固定数目的 &lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt; Go协程 ，所有这些 Go协程 从信道中读取请求的数据；这种情况下 Go协程 的数目限定了同时执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;process&lt;/code&gt; 的并发数量。我们也可以给 &lt;code class=&quot;highlighter-rouge&quot;&gt;Serve&lt;/code&gt; 函数接收一个信道，并在这个信道上接收退出信号。下面的代码示例展示了上面提到的两个技术点：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Serve&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clientRequests&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quit&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Start handlers&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MaxOutstanding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clientRequests&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quit&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// Wait to be told to exit.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;信道中的信道channels-of-channels&quot;&gt;信道中的信道（Channels of channels）&lt;/h3&gt;

&lt;p&gt;Go 最重要的特性之一就是：&lt;strong&gt;信道属于第一级类型&lt;/strong&gt;。信道可以像其他的类型那样初始化和传递，这个特性的一种应用是实现并行安全的多路复用模式。&lt;/p&gt;

&lt;p&gt;在前面的例子中，&lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt; 对请求来说是一个理想的处理器，但是我们并没有提及它处理的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Request&lt;/code&gt; 类型的细节。如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;Request&lt;/code&gt; 类型包含一个用来专门接收响应的信道，那么每个客户端就都可以提供自己的响应信道从而获取响应。下面给出类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;Request&lt;/code&gt; 的一种定义：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;        &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;           &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;resultChan&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Request&lt;/code&gt; 中定义了一个函数一个参数列表，同时还定义了一个信道来接收响应。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Send request&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;clientRequests&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Wait for response.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;answer: %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultChan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在服务器端，只需要修改处理器函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;handle&lt;/code&gt;，代码如下所示：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resultChan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了让功能更丰满，上面的代码显然还有很多东西可以做，但是作为一个无锁的限流、并发、非阻塞的 RPC 系统的框架的原型，已经能说明一些问题了。&lt;/p&gt;

&lt;h3 id=&quot;并行parallelization&quot;&gt;并行（Parallelization）&lt;/h3&gt;

&lt;p&gt;Go协程和信道的另一个应用场景是在多 CPU 核心上进行并发运算。如果某个运算可以被分解成为同步运行的独立子过程，它就可以进行并行计算，其中当某个子过程（Go协程）结束后通过信道来通知它的结束。&lt;/p&gt;

&lt;p&gt;假设我们有一个耗时的向量运算，向量中每个值的运算都是独立的，如下所示：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;float64&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// Apply the operation to v[i], v[i+1] ... up to v[n-1].&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DoSome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Op&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// signal that this piece is done&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以把循环中能够独立出来的逻辑拆分开，让每个 CPU 各自去执行。这些拆分出来的逻辑可以以任意的次序执行，在启动所有的 Go协程 后我们只需要对完成信号的数量进行计数（读取所有信道中的值），代码如下所示：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numCPU&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// number of CPU cores&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DoAll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numCPU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// Buffering optional but sensible.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numCPU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DoSome&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numCPU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numCPU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// Drain the channel.&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numCPU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// wait for one task to complete&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// All done.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相对于为 numCPU 创建常量的值，我们可以通过运行时来准确获取 CPU 的数量。函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;runtime.NumCPU&lt;/code&gt; 返回硬件 CPU 的核心数量，因此我们可以写为 &lt;code class=&quot;highlighter-rouge&quot;&gt;var numCPU = runtime.NumCPU()&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numCPU&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runtime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NumCPU&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Go 中还有一个函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;runtime.GOMAXPROCS&lt;/code&gt;，可以用它来报告 Go 程序可以并发运行的核心数量。它的默认值是 &lt;code class=&quot;highlighter-rouge&quot;&gt;runtime.NumCPU&lt;/code&gt;，开发者可以通过设置相同名称的环境变量，或者通过显式调用这个函数（传一个正整数）来覆盖这个值。如果调用这个函数时传入的是 0，会得到这个值当前的大小。所以，我们还可以向下面这样写：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numCPU&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;runtime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GOMAXPROCS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这里需要注意，我们不要混淆并发和并行的概念。并发是指把代码构造为独立的可执行模块；并行是指高效地在多 CPU 核心上同时执行。尽管 Go 的并发特性可以让构建并行计算变得简单，但是 Go 毕竟是一个并发的语言，它并不是一个并行语言，而且并不是所有的并行问题都契合 Go 的模型。可以查看 &lt;a href=&quot;https://blog.golang.org/2013/01/concurrency-is-not-parallelism.html&quot;&gt;这里&lt;/a&gt;查看更多相关的讨论。&lt;/p&gt;

&lt;h3 id=&quot;缓存漏斗a-leaky-buffer&quot;&gt;缓存漏斗（A leaky buffer）&lt;/h3&gt;

&lt;p&gt;有时候并发编程模型也可以让非并发的想法更容易表达。下面是从 RPC 包抽象出来的一个例子。客户端对应的 Go协程 循环从某些源中（可能是网络）接收数据，为了避免重复分配和回收缓存，它保存了一个空闲列表，并用一个带缓存的信道承载它。如果信道是空的，就分配一个新的缓存，否则从信道中获取一个已有的缓存。消息的缓存一旦就绪，就会被发送到 &lt;code class=&quot;highlighter-rouge&quot;&gt;serverChan&lt;/code&gt; 从而发给服务端。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;freeList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serverChan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Buffer&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// Grab a buffer if available; allocate if not.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;freeList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;// Got one; nothing more to do.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;// None free, so allocate a new one.&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;              &lt;span class=&quot;c&quot;&gt;// Read next message from the net.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;serverChan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;      &lt;span class=&quot;c&quot;&gt;// Send to server.&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;服务端对应的 Go协程 循环获取从客户端传递过来的每个消息，处理完成后把对应的缓存释放并反还给空闲列表。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serverChan&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// Wait for work.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;// Reuse buffer if there's room.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;freeList&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;// Buffer on free list; nothing more to do.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;c&quot;&gt;// Free list full, just carry on.&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码通过几行代码构建了一个漏斗桶的空闲列表。整体来看就是，客户端试图从 &lt;code class=&quot;highlighter-rouge&quot;&gt;freeList&lt;/code&gt; 获取缓存，如果没有可用的缓存它就分配一个新的缓存。服务端用完缓存后把 &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt; 返回给 &lt;code class=&quot;highlighter-rouge&quot;&gt;freeList&lt;/code&gt;，如果空闲列表满了，缓存会被丢弃并最终被垃圾回收器回收掉（在 &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt; 中 &lt;code class=&quot;highlighter-rouge&quot;&gt;default&lt;/code&gt; 的分支会在没有其他的 case 匹配的时候执行，也就意味着上面代码中 &lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt; 语句不会阻塞）。&lt;/p&gt;
</description>
        <pubDate>Sun, 24 Nov 2019 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2019/11/24/effectivego-concurrent.html</link>
        <guid isPermaLink="true">https://jingwei.link/2019/11/24/effectivego-concurrent.html</guid>
        
        <category>golang</category>
        
        <category>基础</category>
        
        <category>实用</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>《原汁原味 Go 语言学习》(10) effective go 空白标识符、嵌套</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#资料&quot; id=&quot;markdown-toc-资料&quot;&gt;资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#空白标识符the-blank-identifier&quot; id=&quot;markdown-toc-空白标识符the-blank-identifier&quot;&gt;空白标识符（The blank identifier）&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#多值赋值语句中的空白标识符the-blank-identifier-in-multiple-assignment&quot; id=&quot;markdown-toc-多值赋值语句中的空白标识符the-blank-identifier-in-multiple-assignment&quot;&gt;多值赋值语句中的空白标识符（The blank identifier in multiple assignment）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#未使用的导入与未使用的变量unused-imports-and-variables&quot; id=&quot;markdown-toc-未使用的导入与未使用的变量unused-imports-and-variables&quot;&gt;未使用的导入与未使用的变量（Unused imports and variables）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#为了副作用的导入import-for-side-effect&quot; id=&quot;markdown-toc-为了副作用的导入import-for-side-effect&quot;&gt;为了副作用的导入（Import for side effect）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#接口检查interface-checks&quot; id=&quot;markdown-toc-接口检查interface-checks&quot;&gt;接口检查（Interface checks）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#嵌套embedding&quot; id=&quot;markdown-toc-嵌套embedding&quot;&gt;嵌套（Embedding）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;资料&quot;&gt;资料&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://golang.google.cn/doc/effective_go.html&quot;&gt;effective go&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/av75898542&quot;&gt;本文的视频地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;空白标识符the-blank-identifier&quot;&gt;空白标识符（The blank identifier）&lt;/h1&gt;

&lt;p&gt;至此为止我们已经提到过很多次空白标识符，在 “for-range 循环” 和 “映射 maps” 小节都有提到。空白标识符可以被任意类型的任意值进行赋值，而且这些值会静默地被丢弃掉。它有点像 Unix 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/null&lt;/code&gt; 文件描述符：空白标识符（_）表示一个只写的值，它可以作为占位符使用，如果有一个变量的值不会被使用但是又必须要设置一个变量来接收这个值，此时就可以使用空白标识符。当然，除此外空白标识符的用处还有很多。&lt;/p&gt;

&lt;h2 id=&quot;多值赋值语句中的空白标识符the-blank-identifier-in-multiple-assignment&quot;&gt;多值赋值语句中的空白标识符（The blank identifier in multiple assignment）&lt;/h2&gt;

&lt;p&gt;for-range 循环中的空白标识符是一种通用情况的特例：属于多值赋值语句。&lt;/p&gt;

&lt;p&gt;如果一个赋值语句需要在左侧有多个变量，但是其中部分变量不会被代码使用，这时候用空白标识符就可以避免创建多余的变量并且显式告诉指明丢弃对应的值。比如，当我们调用返回 值和错误 两个值的函数的时候，如果我们只关注它的错误，就可以使用空白标识符来丢弃这个函数返回的值，比如下面的例子：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsNotExist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s does not exist&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;偶尔情况下你还可以看到忽略错误值的代码，当然这种习惯是非常不好的，在实际的编码实践中也不推荐这么做；最佳实践应该总是检查错误的返回值，毕竟错误中总包含着一些错误的原因，一般是代码应该处理的。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Bad! This code will crash if path does not exist.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IsDir&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s is a directory&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;未使用的导入与未使用的变量unused-imports-and-variables&quot;&gt;未使用的导入与未使用的变量（Unused imports and variables）&lt;/h2&gt;

&lt;p&gt;如果导入了没有使用的包或者声明了没有使用的变量，代码编译的时候编译器都会报错。如果导入一个包却不使用它会让程序显得臃肿而且会拖慢代码的编译速度；一个变量初始化未经使用则意味着计算资源的浪费，有时候甚至意味着很大的缺陷（bug）。不过，代码在开发过程中总会出现尚未使用的导入和变量，如果仅仅为了编译通过而删掉他们后面写到对应的逻辑以后再把它们加回来，这种操作显得有点烦人，此时就可以使用空白标识符：&lt;/p&gt;

&lt;p&gt;下面完成了一半的代码中有两个没有使用过的导入（&lt;code class=&quot;highlighter-rouge&quot;&gt;fmt&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;io&lt;/code&gt;），还有一个没有使用过的变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;fd&lt;/code&gt;，明显下面的这段代码是不会被编译通过的。但是我们可能想提前知道这段代码是不是可以运行，如果能运行，至少能给开发者一点小小的自信（程序员总是希望能早点看到输出结果😆）。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;io&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;log&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;os&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test.go&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fatal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// TODO: use fd.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;为了能让编译器正常编译上面的代码而不报错，我们可以使用空白标识符来标记导入的包；同样的道理，可以把未使用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;fd&lt;/code&gt; 变量赋值给空白标识符。比如下面的代码就可以成功编译通过：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;fmt&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;io&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;log&quot;&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;&quot;os&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// For debugging; delete when done.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;    &lt;span class=&quot;c&quot;&gt;// For debugging; delete when done.&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test.go&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fatal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// TODO: use fd.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;传统意义上来说，为了避免编译器报错的全局声明语句（类似上面代码中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;var _ = fmt.Printf&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;var _ io.Reader&lt;/code&gt;）应该紧跟在导入语句的后面并且注释一下情况，这样未来可以方便地找到这些语句，同时还能够作为一种删除提醒。&lt;/p&gt;

&lt;h2 id=&quot;为了副作用的导入import-for-side-effect&quot;&gt;为了副作用的导入（Import for side effect）&lt;/h2&gt;

&lt;p&gt;在前面的例子中，空白标识符的使用仅仅意味着代码还在开发状态，像 &lt;code class=&quot;highlighter-rouge&quot;&gt;fmt&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;io&lt;/code&gt; 这种未经使用的包最后要么被使用要么被移除。不过真实编码过程中我们可能只需要导入包从而引起某种副作用，但是确实不会在文件中显式地使用这个包。&lt;/p&gt;

&lt;p&gt;比如，包 &lt;code class=&quot;highlighter-rouge&quot;&gt;net/http/pprof&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt; 函数会注册提供调试信息的 HTTP 处理器，虽然这个包有导出的 API，但是导入此包的文件需要的仅仅是调试处理器然后通过它提供的网页页面获取信息，因此导入此包的文件没有必要显式引用这些 API。为了某个副效果而导入某个包却不使用这个包的变量，这种情况就可以给这个包重命名为空白标识符。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;net/http/pprof&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为没有其他地方使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;net/http/pprof&lt;/code&gt; 这个包，这种方式的导入可以很明显地表明目的：在这个文件中这个包没有名字，之所以导入它只是为了获得这个包的副效果。&lt;/p&gt;

&lt;h2 id=&quot;接口检查interface-checks&quot;&gt;接口检查（Interface checks）&lt;/h2&gt;

&lt;p&gt;就像我们在“接口”那一节看到的，类型不需要显式指明自己实现了哪些接口。相反，类型仅需实现接口中包含的方法隐式地来实现接口。实际编码中，大部分的接口转换都是静态的，因此在编译时就会进行类型检查。比如，如果一个函数希望得到 &lt;code class=&quot;highlighter-rouge&quot;&gt;io.Reader&lt;/code&gt; 类型的参数，可以给它传递一个实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;io.Reader&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;*os.File&lt;/code&gt; 类型的变量，如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;*os.File&lt;/code&gt; 没有实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;io.Reader&lt;/code&gt; 接口，代码不能编译通过。&lt;/p&gt;

&lt;p&gt;不过，有时接口的检查是在运行时发生的。比如在 &lt;code class=&quot;highlighter-rouge&quot;&gt;encoding/json&lt;/code&gt; 这个包里面有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Marshaler&lt;/code&gt; 接口，当 JSON 编码器接收到一个实现了这个接口的值的时候，编码器会调用这个值的 &lt;code class=&quot;highlighter-rouge&quot;&gt;marshal&lt;/code&gt; 方法把这个值转化成为 JSON，这个时候就不会调用标准的转换过程了。编码器会在运行时对变量进行类型断言从而检查它的属性：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Marshaler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果仅需要知道某个类型是否实现了某个接口，可以使用空白标识符从而忽略掉类型检查得到的值，如下面代码所示：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Marshaler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;value %v of type %T implements json.Marshaler&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;val&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这种情况下，我们必须在实现了该类型的包内保证它实现了相应的接口。比如，如果类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;json.RawMessage&lt;/code&gt; 需要一个自定义的 &lt;code class=&quot;highlighter-rouge&quot;&gt;JSON&lt;/code&gt; 表示，它应该实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;json.Marshaler&lt;/code&gt; 接口，但是代码中没有任何静态转换让编译器确认这种实现。如果这个类型没有实现相应的接口方法，&lt;code class=&quot;highlighter-rouge&quot;&gt;JSON&lt;/code&gt; 编码器仍然会工作，只是这个时候不会使用自定义的实现而是调用默认的转换方法。为了保证某个类型实现了正确的方法，可以在包中写一个使用了空白标识符的声明：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Marshaler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RawMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这个声明中，赋值语句包含一次转换，从 &lt;code class=&quot;highlighter-rouge&quot;&gt;*RawMessage&lt;/code&gt; 转换为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Marshaler&lt;/code&gt;，这种检查会在编译时进行。如果接口 &lt;code class=&quot;highlighter-rouge&quot;&gt;json.Marshaler&lt;/code&gt; 变化了，这个包不会编译通过，这个时候我们就知道它需要更新了。&lt;/p&gt;

&lt;p&gt;在上面的这种情况下，空白标识符的出现标明声明语句仅仅为了类型检查，而并不会创建一个变量。但是，如果知道类型肯定满足某个接口则没有必要做这种声明。通常情况下，这种用法仅在源码中不存在静态类型转换的情况时使用，而这种情况其实很少见到。&lt;/p&gt;

&lt;h1 id=&quot;嵌套embedding&quot;&gt;嵌套（Embedding）&lt;/h1&gt;

&lt;p&gt;Go 没有子类的概念，但是我们可以通过在结构体或接口中&lt;strong&gt;嵌套&lt;/strong&gt;某个类型来实现类似的功能。&lt;/p&gt;

&lt;p&gt;接口的嵌套非常简单，我们前面提到过的 &lt;code class=&quot;highlighter-rouge&quot;&gt;io.Reader&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;io.Writer&lt;/code&gt; 接口，下面是它们的声明：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Writer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面列出的两个接口都只有一个方法，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;io&lt;/code&gt; 包中还导出了几个包含多个方法的接口。比如，&lt;code class=&quot;highlighter-rouge&quot;&gt;io.ReadWriter&lt;/code&gt; 接口，它包含了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Read&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Write&lt;/code&gt; 两个方法。我们可以直接把两个方法直接写在 &lt;code class=&quot;highlighter-rouge&quot;&gt;io.ReadWriter&lt;/code&gt; 接口定义里，但是更简单更明了的方式是把上面的两个接口 &lt;code class=&quot;highlighter-rouge&quot;&gt;Reader&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Writer&lt;/code&gt; 嵌进新的接口中，就像下面的代码所示：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// ReadWriter is the interface that combines the Reader and Writer interfaces.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReadWriter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Writer&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码的含义是：&lt;code class=&quot;highlighter-rouge&quot;&gt;ReadWriter&lt;/code&gt; 接口，它既是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Reader&lt;/code&gt; 又是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Writer&lt;/code&gt;，它是嵌套起来的接口的联合体（这些联合体之间的方法不能有重名）。需要注意的是，接口只能被嵌套到接口里。&lt;/p&gt;

&lt;p&gt;结构体也有嵌套的用法，但是含义更深远也更复杂。包 &lt;code class=&quot;highlighter-rouge&quot;&gt;bufio&lt;/code&gt; 有两个结构体类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;bufio.Reader&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bufio.Writer&lt;/code&gt;，分别实现了包 &lt;code class=&quot;highlighter-rouge&quot;&gt;io&lt;/code&gt; 中的相关接口。同时 &lt;code class=&quot;highlighter-rouge&quot;&gt;bufio&lt;/code&gt; 包还实现了带缓存的读写器（&lt;code class=&quot;highlighter-rouge&quot;&gt;reader/writer&lt;/code&gt;），通过嵌套的方式在同一个结构中组合 &lt;code class=&quot;highlighter-rouge&quot;&gt;reader&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;writer&lt;/code&gt;。如下代码所示（在组合结构体声明中列出子结构体，但是不给定字段名）：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// ReadWriter stores pointers to a Reader and a Writer.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// It implements io.ReadWriter.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReadWriter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// *bufio.Reader&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Writer&lt;/span&gt;  &lt;span class=&quot;c&quot;&gt;// *bufio.Writer&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;嵌套元素是子结构体的指针，因此初始化时必须要指向合法的结构体才能使用（大家可以回顾初始化一节的内容）。&lt;code class=&quot;highlighter-rouge&quot;&gt;ReadWriter&lt;/code&gt; 结构体也可以写为：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReadWriter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;reader&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Reader&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;writer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Writer&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但如果指定了字段名，为了使用字段里的方法，同时为满足 &lt;code class=&quot;highlighter-rouge&quot;&gt;io&lt;/code&gt; 包对应的接口，不得不手动定义代理方法，比如下面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Read&lt;/code&gt; 方法：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rw&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ReadWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;err&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rw&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;通过直接嵌套结构，我们可以避免上面啰嗦的编码方式。嵌套类型的方法自动提升为组合体的方法，也就是说，&lt;code class=&quot;highlighter-rouge&quot;&gt;bufio.ReadWriter&lt;/code&gt; 不仅实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;bufio.Reader&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;bufio.Writer&lt;/code&gt;这两个接口中的方法，而且同时满足下面的三个接口：&lt;code class=&quot;highlighter-rouge&quot;&gt;io.Reader&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;io.Writer&lt;/code&gt;, 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;io.ReadWriter&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;嵌套与子类继承的模型还是很不一样的。如果我们嵌套了一个类型，则这个类型所有的方法都会成为外面类型的方法，但是当方法被触发调用的时候其接收者依然是里面的类型而不是外面的类型。比如上面的例子中，当 &lt;code class=&quot;highlighter-rouge&quot;&gt;bufio.ReadWriter&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Read&lt;/code&gt; 方法被触发的时候，和上面手动写的代理方法是一样的效果：接收者是 &lt;code class=&quot;highlighter-rouge&quot;&gt;ReadWriter&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;reader&lt;/code&gt; 字段，而不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;ReadWriter&lt;/code&gt; 自己。&lt;/p&gt;

&lt;p&gt;嵌套也可以很便利的应用。下面的例子中，嵌套的字段和普通的命名字段一起使用：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Command&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Logger&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面定义的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Job&lt;/code&gt; 类型有 &lt;code class=&quot;highlighter-rouge&quot;&gt;Print&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Printf&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Println&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;*log.Logger&lt;/code&gt; 的其他方法。我们可以给 &lt;code class=&quot;highlighter-rouge&quot;&gt;Logger&lt;/code&gt; 取一个字段名，但是没必要这么做。现在，我们可以向初始化后的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Job&lt;/code&gt; 类型的对象打日志了：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;starting now...&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Logger&lt;/code&gt; 是结构体 &lt;code class=&quot;highlighter-rouge&quot;&gt;Job&lt;/code&gt; 的一个常规字段，因此我们可以通过常规的方式来构建 &lt;code class=&quot;highlighter-rouge&quot;&gt;Job&lt;/code&gt;，比如下面的方式：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewJob&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;也可以使用下面的符合语法：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;New&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stderr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Job: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ldate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果我们需要直接引用嵌套的字段，字段的名称默认是&lt;strong&gt;忽略包修饰符的名称&lt;/strong&gt;，就像 &lt;code class=&quot;highlighter-rouge&quot;&gt;ReadWriter&lt;/code&gt; 结构体中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Read&lt;/code&gt; 方法一样。如果我们需要访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;Job&lt;/code&gt; 变量中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;*log.Logger&lt;/code&gt;，我们可以写成 &lt;code class=&quot;highlighter-rouge&quot;&gt;job.Logger&lt;/code&gt;，如果想重新定义 &lt;code class=&quot;highlighter-rouge&quot;&gt;Logger&lt;/code&gt; 的方法，这种写法非常有用，如下面的例子。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;job&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{})&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Logger&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%q: %s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;job&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;嵌套类型虽然好用，但同时引入了命名冲突的问题，不过 Go 语言解决这种冲突的方式也很简单。首先，字段或方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt; 会覆盖任何深层嵌套类型的 &lt;code class=&quot;highlighter-rouge&quot;&gt;X&lt;/code&gt;。比如，如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;log.Logger&lt;/code&gt; 包含了一个叫 &lt;code class=&quot;highlighter-rouge&quot;&gt;Command&lt;/code&gt; 的字段或方法，&lt;code class=&quot;highlighter-rouge&quot;&gt;Job&lt;/code&gt; 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Command&lt;/code&gt; 字段会覆盖它。&lt;/p&gt;

&lt;p&gt;其次，如果同样的名字在&lt;strong&gt;同一级的嵌套&lt;/strong&gt;中出现（对比不同级的情况），这会导致错误。如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;Job&lt;/code&gt; 结构包含了另一个名称为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Logger&lt;/code&gt; 的字段或者方法，此时如果再嵌套 &lt;code class=&quot;highlighter-rouge&quot;&gt;log.Logger&lt;/code&gt; 就会报错。然而有特例，如果重复的名称不会在类型定义之外使用，就不会引起问题；这可以保护结构体不会因为被嵌套的外部类型的变化而变得不可用，也就是说当添加的字段与另一个子类型的字段冲突时，如果两个字段都不会被使用，这种情况下是不会报错的。&lt;/p&gt;
</description>
        <pubDate>Sun, 17 Nov 2019 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2019/11/17/effectivego-blank-identifier-embed.html</link>
        <guid isPermaLink="true">https://jingwei.link/2019/11/17/effectivego-blank-identifier-embed.html</guid>
        
        <category>golang</category>
        
        <category>基础</category>
        
        <category>实用</category>
        
        
        <category>golang</category>
        
      </item>
    
      <item>
        <title>MySQL 数据库的基本使用示例</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#写在前面&quot; id=&quot;markdown-toc-写在前面&quot;&gt;写在前面&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#适用人群&quot; id=&quot;markdown-toc-适用人群&quot;&gt;适用人群&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#数据库的基本使用&quot; id=&quot;markdown-toc-数据库的基本使用&quot;&gt;数据库的基本使用&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#数据库的安装与启动&quot; id=&quot;markdown-toc-数据库的安装与启动&quot;&gt;数据库的安装与启动&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#连接数据库服务&quot; id=&quot;markdown-toc-连接数据库服务&quot;&gt;连接数据库服务&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#创建数据库&quot; id=&quot;markdown-toc-创建数据库&quot;&gt;创建数据库&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#创建数据表&quot; id=&quot;markdown-toc-创建数据表&quot;&gt;创建数据表&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#创建-users-表&quot; id=&quot;markdown-toc-创建-users-表&quot;&gt;创建 users 表&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#创建-blogs-表&quot; id=&quot;markdown-toc-创建-blogs-表&quot;&gt;创建 blogs 表&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#创建-comments-表&quot; id=&quot;markdown-toc-创建-comments-表&quot;&gt;创建 comments 表&lt;/a&gt;&lt;/li&gt;
          &lt;li&gt;&lt;a href=&quot;#创建一些假数据便于后面检索使用&quot; id=&quot;markdown-toc-创建一些假数据便于后面检索使用&quot;&gt;创建一些假数据便于后面检索使用&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#join-的使用&quot; id=&quot;markdown-toc-join-的使用&quot;&gt;JOIN 的使用&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#explain-的使用&quot; id=&quot;markdown-toc-explain-的使用&quot;&gt;EXPLAIN 的使用&lt;/a&gt;        &lt;ul&gt;
          &lt;li&gt;&lt;a href=&quot;#在-usersusername-字段上添加索引&quot; id=&quot;markdown-toc-在-usersusername-字段上添加索引&quot;&gt;在 users.username 字段上添加索引&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#小结&quot; id=&quot;markdown-toc-小结&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#参考&quot; id=&quot;markdown-toc-参考&quot;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;对一般的开发者来说，MySQL 安装成功以后，剩下的就是基本的使用了，如果是运维开发，可能还会涉及到数据库的运维。本文暂且不考虑运维上的操作，仅就数据库的使用给出一些示例，主要包括 &lt;code class=&quot;highlighter-rouge&quot;&gt;CURD&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;JOIN&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;EXPLAIN&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;适用人群&quot;&gt;适用人群&lt;/h2&gt;
&lt;p&gt;入门——初级——&lt;strong&gt;中级√&lt;/strong&gt;——高级；本文适应中级及以上。&lt;/p&gt;

&lt;h2 id=&quot;数据库的基本使用&quot;&gt;数据库的基本使用&lt;/h2&gt;
&lt;h3 id=&quot;数据库的安装与启动&quot;&gt;数据库的安装与启动&lt;/h3&gt;
&lt;p&gt;目前常见的操作系统有三类：Linux、Windows、Mac。不同平台安装软件的方式各异，安装过程中可能遇到的问题也各不相同，大家可以根据自己所使用的平台进行探索。因为本人使用的是 Mac，因此只给出 Mac 操作系统上 MySQL 的安装与启动。&lt;/p&gt;

&lt;p&gt;简单总结下来就是下面几个命令&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 安装 homebrew， 参考 https://brew.sh/&lt;/span&gt;
/usr/bin/ruby &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;$(&lt;/span&gt;curl &lt;span class=&quot;nt&quot;&gt;-fsSL&lt;/span&gt; https://raw.githubusercontent.com/Homebrew/install/master/install&lt;span class=&quot;si&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 查找可以安装的 mysql 方案&lt;/span&gt;
brew search mysql

&lt;span class=&quot;c&quot;&gt;# 安装 5.7 版本的  mysql&lt;/span&gt;
brew &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;mysql@5.7

&lt;span class=&quot;c&quot;&gt;# 查看 mysql@5.7 的安装信息、启动信息等&lt;/span&gt;
brew info mysql@5.7

&lt;span class=&quot;c&quot;&gt;# 开机启动 mysql@5.7&lt;/span&gt;
brew services start mysql@5.7
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;连接数据库服务&quot;&gt;连接数据库服务&lt;/h3&gt;
&lt;p&gt;启动 MySQL 后，我们可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;ps -ef |grep mysql&lt;/code&gt; 来查看与 MySQL 相关的进程，可以发现 后台会运行一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;mysqld&lt;/code&gt; 的进程，也就是说我们通常所说的 “连接数据库” 其实指的是连接 &lt;code class=&quot;highlighter-rouge&quot;&gt;mysqld&lt;/code&gt; 提供的数据库服务。&lt;/p&gt;

&lt;p&gt;一般本地（自己的电脑上面）安装完 MySQL 后，会默认安装 &lt;code class=&quot;highlighter-rouge&quot;&gt;mysql&lt;/code&gt; 这个命令，可以用它来连接 &lt;code class=&quot;highlighter-rouge&quot;&gt;mysqld&lt;/code&gt; 提供的服务（因为真正提供数据库服务的是 mysqld，或许 MySQL 应该叫 MySQLD 比较好？ 😆）。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 连接本地 localhost 端口为 3306 的数据库 hello&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 使用 root 用户，且要求输入密码&lt;/span&gt;
mysql &lt;span class=&quot;nt&quot;&gt;-h&lt;/span&gt; localhost &lt;span class=&quot;nt&quot;&gt;-P&lt;/span&gt; 3306 &lt;span class=&quot;nt&quot;&gt;-D&lt;/span&gt; hello &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; root &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 我们可以忽略 -h 和 -P 来简化上面的语句&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 下面的语句表示： 以 root 用户连接本地 3306 端口上的数据库 hello&lt;/span&gt;
mysql &lt;span class=&quot;nt&quot;&gt;-D&lt;/span&gt; hello &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; root &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 如果不需要指定连接哪个数据库，还可以省略 -D 及其参数&lt;/span&gt;
mysql &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; root &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# 如果需要指定字符集为 utf8mb4，需要添加（如果要存储 emoji 就必须要指定这个字符集）&lt;/span&gt;
mysql &lt;span class=&quot;nt&quot;&gt;-u&lt;/span&gt; root &lt;span class=&quot;nt&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--default-character-set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;utf8mb4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;创建数据库&quot;&gt;创建数据库&lt;/h3&gt;
&lt;p&gt;连接到数据库以后，我们可以通过下面的语句创建一个数据库。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- SQL 的注释使用的是 双横线 “--”&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 如果 hello 数据库已经存在，就显式地先删除这个数据库&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 然后创建一个名为 hello 的数据库，并指定其默认的字符集为 utf8mb4&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 大家可以自行搜索 MySQL utf8mb4 相关的内容&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DATABASE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IF&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EXISTS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DATABASE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`hello`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`utf8mb4`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- 有了数据库以后就可以使用这个数据库了，然后才可以在数据库中创建表&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;USE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;创建数据表&quot;&gt;创建数据表&lt;/h3&gt;

&lt;p&gt;接下来我们模仿一个博客系统创建几个数据表，分别包括用户表 users、博客表 blogs 和评论表 comments。&lt;/p&gt;

&lt;p&gt;在创建表的时候我们有几个默认项，数据库引擎使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;InnoDB&lt;/code&gt;（小白用户只需要记住 InnoDB 可以满足绝大部分场景），字符集使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;utf8mb4&lt;/code&gt;。由于 &lt;code class=&quot;highlighter-rouge&quot;&gt;InnodB&lt;/code&gt; 的 “聚簇索引” 和“二级索引包含引用行的主键列”的特性，默认情况下我们会创建一个类型为 &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; 的主键  &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;创建-users-表&quot;&gt;创建 users 表&lt;/h4&gt;

&lt;p&gt;下面的语句创建了用户 users 表。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 为了试验环境的干净整洁，首先检查是否已经存在 users 表&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 如果已经存在 users 表就先删除掉，接着创建 users 表&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 用户表中包含的字段及其含义可以查看 COMMENT 中备注的内容&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EXISTS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`users`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'主键，用户 id'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`created_at`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;datetime&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'创建时间'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`updated_at`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;datetime&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'更新时间'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`username`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'用户名'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`birthday`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;datetime&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'生日日期'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`idx_user_created_at`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`created_at`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;USING&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BTREE&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CHARSET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8mb4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;创建-blogs-表&quot;&gt;创建 blogs 表&lt;/h4&gt;

&lt;p&gt;下面的语句创建了博客 blogs 表。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 为了试验环境的干净整洁，首先检查是否已经存在 blogs 表&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 如果已经存在 blogs 表就先删除掉，接着创建 blogs 表&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 用户表中包含的字段及其含义可以查看 COMMENT 中备注的内容&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EXISTS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blogs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`blogs`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'主键，博客 id'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`created_at`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;datetime&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'创建时间'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`updated_at`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;datetime&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'更新时间'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`user_id`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'用户id'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`title`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'博客标题，最多 50 个字符'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`content`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'博客内容'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`idx_blogs_created_at`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`created_at`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;USING&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BTREE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`idx_blogs_user_id`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`user_id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;USING&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BTREE&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CHARSET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8mb4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;创建-comments-表&quot;&gt;创建 comments 表&lt;/h4&gt;

&lt;p&gt;下面的语句创建了评论 comments 表。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 为了试验环境的干净整洁，首先检查是否已经存在 comments 表&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 如果已经存在 comments 表就先删除掉，接着创建 comments 表&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- 用户表中包含的字段及其含义可以查看 COMMENT 中备注的内容&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EXISTS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`comments`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'主键，评论 id'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`created_at`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;datetime&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'创建时间'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`updated_at`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;datetime&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'更新时间'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`user_id`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'用户 id'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`blog_id`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'博客 id'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`content`&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2048&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COMMENT&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'评论内容，限制最多 2048 个字符'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`idx_blogs_created_at`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`created_at`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;USING&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BTREE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`idx_blogs_user_id`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`user_id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;USING&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BTREE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`idx_blogs_blog_id`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`blog_id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;USING&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BTREE&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CHARSET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8mb4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;创建一些假数据便于后面检索使用&quot;&gt;创建一些假数据便于后面检索使用&lt;/h4&gt;
&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 首先下面手动给每个表插入了一条记录&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`users`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`username`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`birthday`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VALUES&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'ws_by_hand_1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`blogs`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`user_id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`title`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`content`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VALUES&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'海燕'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'高尔基的作品。'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`blogs`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`user_id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`title`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`content`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VALUES&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'我的大学'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'高尔基的另一部作品。'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`comments`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`user_id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`blog_id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`content`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VALUES&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'我也喜欢高尔基的作品😆'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`comments`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`user_id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`blog_id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`content`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VALUES&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'2'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'这一部我也很喜欢😆'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- 为了说明问题，下面定义了一个创建多个虚拟用户的过程&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;DELIMITER&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PROCEDURE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;EXISTS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mock_users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;PROCEDURE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mock_users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;BEGIN&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;DECLARE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;INT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;WHILE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DO&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`users`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`username`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`birthday`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VALUES&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CONCAT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;&quot;ws_auto_&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`blogs`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`user_id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`title`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`content`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VALUES&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'背影'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'朱自清的作品。'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INTO&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`comments`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`user_id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`blog_id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`content`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;VALUES&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'我也喜欢😆'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;END&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WHILE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;END&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;DELIMITER&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- 调用 mock_users 生成多个用户账户，以及对应的 blogs 和 comments&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CALL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mock_users&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;join-的使用&quot;&gt;JOIN 的使用&lt;/h3&gt;
&lt;p&gt;我们可以通过 JOIN 的方式来获取某个用户发表的博客的所有内容，以及其博客所获得的评论内容。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blog_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blog_title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blog_content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comment_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comment_user_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comment_content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;cu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;username&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comment_username&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blogs&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comments&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blog_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cu&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'ws_by_hand_1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;获取到的结果如下图所示（可以通过指定字段来选择性的检出对应的字段的内容）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/mysql-curd-join-explain-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;explain-的使用&quot;&gt;EXPLAIN 的使用&lt;/h3&gt;
&lt;p&gt;因为我们的表的内容比较少，因此运行上面 &lt;code class=&quot;highlighter-rouge&quot;&gt;JOIN&lt;/code&gt; 的内容不会有慢的感觉，但是我们依然可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;EXPLAIN&lt;/code&gt; 进行一番探索。&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;EXPLAIN&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blog_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;title&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blog_title&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blog_content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comment_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comment_user_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comment_content&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;cu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;username&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comment_username&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;FROM&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;blogs&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comments&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;blog_id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;LEFT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;JOIN&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;users&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cu&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_id&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'ws_by_hand_1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;EXPALIN&lt;/code&gt; 代码运行后得到的结果如下图所示。我们可以通过查看 &lt;code class=&quot;highlighter-rouge&quot;&gt;type&lt;/code&gt; 一列探索索引的使用情况，发现 &lt;code class=&quot;highlighter-rouge&quot;&gt;users as u&lt;/code&gt; 表扫了全量表（&lt;em&gt;type 为 ALL&lt;/em&gt;），当我们的 user 表非常大的情况下，这里肯定会存在问题。其实在创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;users&lt;/code&gt; 表的时候我刻意少创建了一个索引，理论上应该在 &lt;code class=&quot;highlighter-rouge&quot;&gt;users.username&lt;/code&gt; 这个字段上添加索引。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/mysql-curd-join-explain-02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;在-usersusername-字段上添加索引&quot;&gt;在 users.username 字段上添加索引&lt;/h4&gt;

&lt;p&gt;可以通过下面的语句为 &lt;code class=&quot;highlighter-rouge&quot;&gt;users.username&lt;/code&gt; 字段添加索引：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`users`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ADD&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`idx_user_username`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`username`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在添加完索引以后，在此 &lt;code class=&quot;highlighter-rouge&quot;&gt;EXPLAIN&lt;/code&gt; 我们的 &lt;code class=&quot;highlighter-rouge&quot;&gt;JOIN&lt;/code&gt; 语句，可以得到下图的结果。可以发现 &lt;code class=&quot;highlighter-rouge&quot;&gt;users as u&lt;/code&gt;的 type 已经变成了字段 &lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt; （&lt;code class=&quot;highlighter-rouge&quot;&gt;idx_user_username&lt;/code&gt;）上的索引&lt;code class=&quot;highlighter-rouge&quot;&gt;ref&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/pic/mysql-curd-join-explain-03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文就数据库的使用给出一些示例，通过实例代码的方式给出 &lt;code class=&quot;highlighter-rouge&quot;&gt;CURD&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;JOIN&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;EXPLAIN&lt;/code&gt;的使用方式，在实际生产过程中可以为大家提供一些参考。
对于 ORM 工具的使用，在检索的过程中本质是 SQL 语句的拼装、检索结果的解析，在数据库层面了解 SQL 无疑能够增强大家对 ORM 的使用的理解，从而写出更加高效可靠的代码。&lt;/p&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://brew.sh/&quot;&gt;The missing package manager for macOS (or Linux) — Homebrew&lt;/a&gt; macOS 上强大的包管理器&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/tufujie/p/9413852.html&quot;&gt;MySQL Explain详解 - 博客园&lt;/a&gt; 比较详尽的介绍 explain 的内容&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2019/10/19/mac-mysql-reinstall.html&quot;&gt;卸载 macOS 中的 MySQL 时遇到的疑问 - 敬维&lt;/a&gt; 在 macOS 上安装/卸载 mysql 的介绍&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 16 Nov 2019 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2019/11/16/mysql-curd-join-explain.html</link>
        <guid isPermaLink="true">https://jingwei.link/2019/11/16/mysql-curd-join-explain.html</guid>
        
        <category>数据库</category>
        
        <category>经验</category>
        
        <category>实用</category>
        
        
        <category>数据库</category>
        
      </item>
    
      <item>
        <title>《原汁原味 Go 语言学习》(9) effective go 接口及泛型</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#资料&quot; id=&quot;markdown-toc-资料&quot;&gt;资料&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#接口与其他类型interfaces-and-other-types&quot; id=&quot;markdown-toc-接口与其他类型interfaces-and-other-types&quot;&gt;接口与其他类型（Interfaces and other types）&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#接口interfaces&quot; id=&quot;markdown-toc-接口interfaces&quot;&gt;接口（Interfaces）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#类型转换conversions&quot; id=&quot;markdown-toc-类型转换conversions&quot;&gt;类型转换（Conversions）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#接口转换与类型断言interface-conversions-and-type-assertions&quot; id=&quot;markdown-toc-接口转换与类型断言interface-conversions-and-type-assertions&quot;&gt;接口转换与类型断言（Interface conversions and type assertions）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#泛型generality&quot; id=&quot;markdown-toc-泛型generality&quot;&gt;泛型（Generality）&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#接口与方法interfaces-and-methods&quot; id=&quot;markdown-toc-接口与方法interfaces-and-methods&quot;&gt;接口与方法（Interfaces and methods）&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;资料&quot;&gt;资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://golang.google.cn/doc/effective_go.html&quot;&gt;effective go&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/av75076225&quot;&gt;本文的视频地址&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;接口与其他类型interfaces-and-other-types&quot;&gt;接口与其他类型（Interfaces and other types）&lt;/h1&gt;

&lt;h2 id=&quot;接口interfaces&quot;&gt;接口（Interfaces）&lt;/h2&gt;

&lt;p&gt;在 Go 中，可以用接口来指定一个对象的行为：如果一个对象可以做&lt;strong&gt;某件事情&lt;/strong&gt;，那么它就可以用在&lt;strong&gt;某个指定的地方&lt;/strong&gt;。之前已经看到过几个简单的例子：① 实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; 方法可以自定义类型的打印格式，② &lt;code class=&quot;highlighter-rouge&quot;&gt;Fprintf&lt;/code&gt; 可以向任何实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Write&lt;/code&gt; 方法的类型打印内容。在 Go 源码中，有很多只包含一两个方法的接口，一般情况下这些接口的名称直接衍生自他们所包含的方法，比如只有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Write&lt;/code&gt; 方法的 &lt;code class=&quot;highlighter-rouge&quot;&gt;io.Writer&lt;/code&gt; 接口。&lt;/p&gt;

&lt;p&gt;一个类型可以实现多个接口。比如包 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt; 可以给实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort.Interface&lt;/code&gt; 接口的集合进行排序，也就是只要集合类型实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;Len()&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Less(i, j int) bool&lt;/code&gt;, 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Swap(i, j int)&lt;/code&gt; 方法，就可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort.Sort&lt;/code&gt; 进行排序了；在实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort.Interface&lt;/code&gt; 接口后，集合还可以通过实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;fmt.Stringer&lt;/code&gt; 接口来自定义输出格式。下面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sequence&lt;/code&gt; 同时实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort.Interface&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;fmt.Stringer&lt;/code&gt; 两个接口：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// Methods required by sort.Interface.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Less&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// Copy returns a copy of the Sequence.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;copy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;make&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// Method for printing - sorts the elements before printing.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Make a copy; don't overwrite argument.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;[&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;elem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Loop is O(N²); will fix that in next example.&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;elem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;]&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;类型转换conversions&quot;&gt;类型转换（Conversions）&lt;/h2&gt;

&lt;p&gt;上面 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sequence&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; 方法（复杂度为 O(N²)）做了很多 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sprint&lt;/code&gt; 已经做完的事情——&lt;code class=&quot;highlighter-rouge&quot;&gt;Sprint&lt;/code&gt; 函数内置了打印集合类型值的功能。因此如果调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sprint&lt;/code&gt; 前我们把 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sequence&lt;/code&gt; 转换为普通的 &lt;code class=&quot;highlighter-rouge&quot;&gt;[]int&lt;/code&gt;，就可以避免重复的工作同时还会加快执行速度。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个方法是另一个在 &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; 方法中安全调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sprintf&lt;/code&gt; 函数的例子（不会触发循环调用）。因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sequence&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;[]int&lt;/code&gt; 这两个类型只是类型名不同，其底层的数据结构是一模一样的，因此这两个类型的变量可以相互进行转换。这里的类型转换并不会创建新的值，它只是临时把一个存在的值作为另一种类型的值来看待（有特例，比如 go 允许整数转换成为浮点数，而这种转换会产生一个新的值。）&lt;/p&gt;

&lt;p&gt;在 Go 中，我们可以通过类型转换的方式获取新类型上的方法的调用权限，这种方式算是一种惯用手法吧。比如，我们可以使用已经存在的类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort.IntSlice&lt;/code&gt; 来减少代码量：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// Method for printing - sorts the elements before printing&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Copy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntSlice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Sprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码把 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sequence&lt;/code&gt; 转换为不同的类型从而使用每种类型包含的功能，每种转换完成一部分的工作，一起达成最后期望的效果；语句 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort.IntSlice(s)&lt;/code&gt; 把 &lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt; 转换为 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort.IntSlice&lt;/code&gt; 类型，这种类型实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort.Interface&lt;/code&gt; 接口，因此可以直接调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sort()&lt;/code&gt; 方法，就避免我们自己在定义 &lt;code class=&quot;highlighter-rouge&quot;&gt;Len/Less/Swap&lt;/code&gt; 方法了。这种类型变来变去的用法看起来不同寻常，但是写起来很高效。&lt;/p&gt;

&lt;h2 id=&quot;接口转换与类型断言interface-conversions-and-type-assertions&quot;&gt;接口转换与类型断言（Interface conversions and type assertions）&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;类型 switch&lt;/strong&gt; 语法是类型转换的一种方式：他首先接收某个&lt;strong&gt;接口变量&lt;/strong&gt;，然后在每个 case 里把接口变量转换为对应的类型。下面的代码是简化版的 &lt;code class=&quot;highlighter-rouge&quot;&gt;fmt.Printf&lt;/code&gt; 方法，用来展示如何通过类型 switch 把一个接口变量转换成字符串。如果接口变量已经是一个字符串，只需要把这个字符串值返回就可以了；否则假如它实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt; 方法（实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Stringer&lt;/code&gt; 接口），我们可以通过调用这个方法并返回其结果。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stringer&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;// Value provided by caller.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stringer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码里，第一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt; 直接使用了接口变量的底层数据；第二个 &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt; 把一个接口转换成另一个接口（&lt;code class=&quot;highlighter-rouge&quot;&gt;interface{}&lt;/code&gt; 的值转换为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Stringer&lt;/code&gt; 类型的值），在 Go 中这种把类型杂糅在一起使用的场景也是比较多见的。&lt;/p&gt;

&lt;p&gt;为了转换类型上面大动干戈地使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;switch...case...&lt;/code&gt;语句，假如我们知道某个值保存的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;string&lt;/code&gt; 类型的值，该怎么直接把这个值解析出来？当然可以使用只有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;case&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;switch&lt;/code&gt; 语句来实现，但是可以更简单地通过&lt;strong&gt;类型断言&lt;/strong&gt;来实现。类型断言可以在接口类型的值上面抽取特定类型的值。它的语法是从 &lt;strong&gt;类型 switch&lt;/strong&gt; 中借鉴的，但是 switch 中使用的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;value.(type)&lt;/code&gt;，类型断言的括号中直接显式指定类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;value.(typeName)&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;typeName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;value.(typeName)&lt;/code&gt; 的结果是静态类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;typeName&lt;/code&gt; 对应的新值。这个静态类型要么是接口变量的底层数据类型，要么是接口变量的底层数据类型实现的另一个接口。如果我们已经知道某个值存储的是字符串，直接通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;str := value.(string)&lt;/code&gt; 就可以获取到。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;类似 &lt;code class=&quot;highlighter-rouge&quot;&gt;str := value.(string)&lt;/code&gt; 的写法很简单很易用，但是如果在 &lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt; 中保存的不是一个字符串，会产生运行时错误导致代码崩溃。为了避免这种情况，可以使用 “逗号与ok” 的惯用语法来检测相应的值是否是字符串：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;string value is: %q&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;value is not a string&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果类型断言失败了，&lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt; 依然存在且是字符串类型，只不过它的值会是空字符串。&lt;/p&gt;

&lt;p&gt;为了说明这种 “逗号与ok” 形式的类型断言的功能，下面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;if - else&lt;/code&gt; 表达式与上面的类型 switch 示例实现了相同的功能。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Stringer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ok&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;泛型generality&quot;&gt;泛型（Generality）&lt;/h2&gt;

&lt;p&gt;如果类型的存在只是为了实现某个接口，除了接口中限定必须要实现的方法没有其他需要导出的方法，此时就没有必要导出这个类型，只需导出对应接口即可，表明这个类型的值除了接口里定义的方法外没有其他的方法。假如对同一个接口有不同的实现，这种做法还能避免重复地给方法写文档（只需要在接口里注明每种方法的作用、用法，各个类型实现这些方法的时候只需要简单注明是哪个接口的方法就可以了）。&lt;/p&gt;

&lt;p&gt;在这种模式下，类型的构造器应该返回接口的值而不是相应的类型的值。比如，在哈希库 &lt;code class=&quot;highlighter-rouge&quot;&gt;crc32.NewIEEE&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;adler32.New&lt;/code&gt; 两个构造器返回的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;hash.Hash32&lt;/code&gt; 接口类型的值。如果要把 CRC-32 的算法替代为 Adler-32 的算法，只需要改变一下调用的构造器，其他的不需要任何改变。&lt;/p&gt;

&lt;p&gt;同样的，可以让不同 &lt;code class=&quot;highlighter-rouge&quot;&gt;crypto&lt;/code&gt; 包中的流密码算法与块加密算法分开。在 &lt;code class=&quot;highlighter-rouge&quot;&gt;crypto/cipher&lt;/code&gt; 包中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Block&lt;/code&gt; 接口限定了块加密算法对某个独立的数据块进行加密的行为；为了通用性，使用实现 &lt;code class=&quot;highlighter-rouge&quot;&gt;Block&lt;/code&gt; 接口的加密包来创建流加密器，从而封装块密码算法的细节，把使用者的注意力解放出来；最后为了通用性，返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&lt;/code&gt; 接口类型的数据。&lt;/p&gt;

&lt;p&gt;接口 &lt;code class=&quot;highlighter-rouge&quot;&gt;crypto/cipher&lt;/code&gt; 的源码如下：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Block&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;BlockSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Encrypt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Decrypt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stream&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;XORKeyStream&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面是 CTR（计数器模式）流的定义，它可以把块密码转换成为流密码；可以看到块密码相关的细节被抽象了：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// NewCTR returns a Stream that encrypts/decrypts using the given Block in&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// counter mode. The length of iv must be the same as the Block's block size.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NewCTR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iv&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Stream&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NewCTR&lt;/code&gt; 不局限应用到某种特定的加密算法和数据源，它能够应用在所有实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Block&lt;/code&gt; 接口和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&lt;/code&gt; 接口的加密算法上面。同时因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;NewCTR&lt;/code&gt; 返回的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Stream&lt;/code&gt; 接口类型，因此用其他的加密算法替代 &lt;code class=&quot;highlighter-rouge&quot;&gt;CTR&lt;/code&gt; 算法也很简单，只需要把调用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;NewCTR&lt;/code&gt; 的地方替换成为其他加密算法的构造器就可以了。&lt;/p&gt;

&lt;h2 id=&quot;接口与方法interfaces-and-methods&quot;&gt;接口与方法（Interfaces and methods）&lt;/h2&gt;

&lt;p&gt;在 Go 中几乎所有东西都可以关联方法，都可以满足某个接口。其中一个例子是定义了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt; 接口的 &lt;code class=&quot;highlighter-rouge&quot;&gt;http&lt;/code&gt; 包：任何实现了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Handler&lt;/code&gt; 接口的对象都可以处理 HTTP 请求。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Handler&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;ResponseWriter&lt;/code&gt; 本身就是一个接口，它提供了响应客户端的几个方法，包含标准的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Write&lt;/code&gt; 方法，因此 &lt;code class=&quot;highlighter-rouge&quot;&gt;http.ResponseWriter&lt;/code&gt; 可以被使用在任何应用 &lt;code class=&quot;highlighter-rouge&quot;&gt;io.Writer&lt;/code&gt; 的地方。&lt;code class=&quot;highlighter-rouge&quot;&gt;Request&lt;/code&gt; 是一个结构体，包含了从客户端解析出来的请求体。&lt;/p&gt;

&lt;p&gt;为了简化，让我们忽略 POSTs 并且假设 HTTP 请求只有 GETs。下面是一个短小但是完整的 HTTP 请求处理器（实现了 ServerHTTP 方法），它能够用于计数页面被查看的次数。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Simple counter server.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ctr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;counter = %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;（感兴趣的话可以探索一下 &lt;code class=&quot;highlighter-rouge&quot;&gt;Fprintf&lt;/code&gt; 是如何把内容打印到 &lt;code class=&quot;highlighter-rouge&quot;&gt;http.ResponseWriter&lt;/code&gt; 的）&lt;/p&gt;

&lt;p&gt;作为参考，下面的代码展示了如果把这样的服务绑定到 URL 树上的：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;net/http&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ctr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/counter&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ctr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在这个例子里其实整数类型也可以满足需求，那为什么还要把 &lt;code class=&quot;highlighter-rouge&quot;&gt;Counter&lt;/code&gt; 声明成一个结构体呢？（这里需要注意接收者必须是指针才可以让调用者感知到它的增加）&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Simpler counter server.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Counter&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fprintf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;counter = %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ctr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果页面被访问时需要进行通知，代码该怎么写？此时可以考虑给网页绑一个信道：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// A channel that sends a notification on each visit.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// (Probably want the channel to be buffered.)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Chan&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Chan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fprint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;notification sent&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后，如果我们想展示服务器启动时在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/args&lt;/code&gt; 路径里传递的参数，可以很容易地写一个函数来打印这些参数。&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArgServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Println&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那我们该怎么把它变成一个 HTTP 服务呢？我们可以定义任意的类型并给这个类型写一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;ArgServer&lt;/code&gt; 方法，然后不使用接收者的值就可以了，但是有一个更好的方法：因为我们可以给任何类型（除了指针和接口）定义方法，因此我们可以给函数定义方法。在 &lt;code class=&quot;highlighter-rouge&quot;&gt;http&lt;/code&gt; 中就包含这样的代码：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// The HandlerFunc type is an adapter to allow the use of&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// ordinary functions as HTTP handlers.  If f is a function&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// with the appropriate signature, HandlerFunc(f) is a&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// Handler object that calls f.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HandlerFunc&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// ServeHTTP calls f(w, req).&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HandlerFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HandlerFunc&lt;/code&gt; 类型定义了 &lt;code class=&quot;highlighter-rouge&quot;&gt;ServeHTTP&lt;/code&gt; 方法，因此这个类型的值可以处理 HTTP 请求。可以琢磨一下上面代码中 &lt;code class=&quot;highlighter-rouge&quot;&gt;ServeHTTP&lt;/code&gt; 这个方法的使用：接受者是一个函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;ServeHTTP&lt;/code&gt; 方法的内部调用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;f&lt;/code&gt;。可能这看起来有一点奇怪，但是这和 “接收者是信道并且在对应的方法中向信道中发送内容” 是一样的设计模式。&lt;/p&gt;

&lt;p&gt;为了让 &lt;code class=&quot;highlighter-rouge&quot;&gt;ArgServer&lt;/code&gt; 注册为 HTTP 服务器，我们可以先修改它让它有正确的签名：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// Argument server.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArgServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fprintln&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面的代码中 &lt;code class=&quot;highlighter-rouge&quot;&gt;ArgServer&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;HandlerFunc&lt;/code&gt; 有相同的签名，因此我们可以把它转换为&lt;code class=&quot;highlighter-rouge&quot;&gt;HandlerFunc&lt;/code&gt; 类型从而可以使用这个类型的方法，就好像我们把 &lt;code class=&quot;highlighter-rouge&quot;&gt;Sequence&lt;/code&gt; 转换为 &lt;code class=&quot;highlighter-rouge&quot;&gt;IntSlice&lt;/code&gt; 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;IntSlice.Sort&lt;/code&gt; 一样。下面的代码简洁明了：&lt;/p&gt;

&lt;div class=&quot;language-go highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/args&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HandlerFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ArgServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这样当有人访问了页面 &lt;code class=&quot;highlighter-rouge&quot;&gt;/args&lt;/code&gt;，处理器在这个页面安装了类型为 &lt;code class=&quot;highlighter-rouge&quot;&gt;HandlerFunc&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;ArgServer&lt;/code&gt;，因此 HTTP 服务器会触发 &lt;code class=&quot;highlighter-rouge&quot;&gt;HandlerFunc&lt;/code&gt; 类型的方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;ServeHTTP&lt;/code&gt;，上面的代码里对应的接收器是 &lt;code class=&quot;highlighter-rouge&quot;&gt;ArgServer&lt;/code&gt;，并且会通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;HandlerFunc.ServeHTTP&lt;/code&gt; 内的 &lt;code class=&quot;highlighter-rouge&quot;&gt;f(w, req)&lt;/code&gt;）调用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ArgServer&lt;/code&gt; 方法，如此参数就被展示出来。&lt;/p&gt;

&lt;p&gt;在这一小节中我们在结构体、整数、信道和函数上面分别创建了 HTTP 服务器，可以做到这一切都是因为接口的纯粹性：① 接口只关注方法，②可以给几乎所有的类型（除了指针和接口）关联方法从而实现接口。&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Nov 2019 00:00:00 +0800</pubDate>
        <link>https://jingwei.link/2019/11/09/effectivego-interface.html</link>
        <guid isPermaLink="true">https://jingwei.link/2019/11/09/effectivego-interface.html</guid>
        
        <category>golang</category>
        
        <category>基础</category>
        
        <category>实用</category>
        
        
        <category>golang</category>
        
      </item>
    
  </channel>
</rss>